{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n\n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          // Notify all subscribers\n          this.subscribers.forEach((callback, id) => {\n            console.log(`Notifying subscriber ${id}`);\n            callback(data);\n          });\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n        this.attemptReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket Error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n    }\n  }\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n    }\n  }\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n\n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    }\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n\n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","subscribers","Map","isConnected","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","console","log","connect","WebSocket","onopen","payload","method","send","JSON","stringify","onmessage","event","data","parse","forEach","callback","id","error","onclose","attemptReconnect","onerror","setTimeout","subscribeToAccountTrades","accounts","Array","isArray","length","keys","subscribeToTokenTrades","tokens","subscribe","set","size","from","unsubscribe","delete","disconnect","clearTimeout","close","websocketService"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/src/utils/websocket.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        \n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          // Notify all subscribers\n          this.subscribers.forEach((callback, id) => {\n            console.log(`Notifying subscriber ${id}`);\n            callback(data);\n          });\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n        this.attemptReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket Error:', error);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n    }\n  }\n\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n    }\n  }\n\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n    \n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    }\n\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n    \n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}