{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n\n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'connected'\n          });\n        });\n\n        // Log subscription confirmation\n        console.log('Subscribed to new token events');\n      };\n      this.ws.onmessage = event => {\n        try {\n          const rawData = JSON.parse(event.data);\n          console.log('Raw WebSocket message:', rawData);\n\n          // Transform the data into our expected format\n          let transformedData;\n          if (rawData.event === 'newToken') {\n            var _rawData$token, _rawData$token2, _rawData$token3, _rawData$token4;\n            transformedData = {\n              type: 'newToken',\n              data: {\n                name: ((_rawData$token = rawData.token) === null || _rawData$token === void 0 ? void 0 : _rawData$token.name) || 'Unknown',\n                address: ((_rawData$token2 = rawData.token) === null || _rawData$token2 === void 0 ? void 0 : _rawData$token2.address) || rawData.tokenAddress,\n                timestamp: rawData.timestamp || new Date().toISOString(),\n                initialPrice: parseFloat(((_rawData$token3 = rawData.token) === null || _rawData$token3 === void 0 ? void 0 : _rawData$token3.price) || rawData.price || '0'),\n                initialLiquidity: parseFloat(((_rawData$token4 = rawData.token) === null || _rawData$token4 === void 0 ? void 0 : _rawData$token4.liquidity) || rawData.liquidity || '0')\n              }\n            };\n          } else {\n            transformedData = rawData;\n          }\n          console.log('Transformed data:', transformedData);\n\n          // Notify all subscribers\n          this.subscribers.forEach((callback, id) => {\n            console.log(`Notifying subscriber ${id}`);\n            callback(transformedData);\n          });\n        } catch (error) {\n          console.error('Error processing WebSocket message:', error);\n          console.error('Raw message:', event.data);\n        }\n      };\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'disconnected'\n          });\n        });\n        this.attemptReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket Error:', error);\n        // Notify all subscribers of connection error\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'error',\n            error\n          });\n        });\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to account trades:', accounts);\n    }\n  }\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to token trades:', tokens);\n    }\n  }\n\n  // Method to check connection status\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      subscriberCount: this.subscribers.size\n    };\n  }\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n\n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    } else if (this.isConnected) {\n      // If already connected, notify the new subscriber of current status\n      callback({\n        type: 'connection',\n        status: 'connected'\n      });\n    }\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n\n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","subscribers","Map","isConnected","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","console","log","connect","WebSocket","onopen","payload","method","send","JSON","stringify","forEach","callback","id","type","status","onmessage","event","rawData","parse","data","transformedData","_rawData$token","_rawData$token2","_rawData$token3","_rawData$token4","name","token","address","tokenAddress","timestamp","Date","toISOString","initialPrice","parseFloat","price","initialLiquidity","liquidity","error","onclose","attemptReconnect","onerror","setTimeout","subscribeToAccountTrades","accounts","Array","isArray","length","keys","subscribeToTokenTrades","tokens","getConnectionStatus","subscriberCount","size","subscribe","set","from","unsubscribe","delete","disconnect","clearTimeout","close","websocketService"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/src/utils/websocket.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        \n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'connected' });\n        });\n\n        // Log subscription confirmation\n        console.log('Subscribed to new token events');\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const rawData = JSON.parse(event.data);\n          console.log('Raw WebSocket message:', rawData);\n\n          // Transform the data into our expected format\n          let transformedData;\n          if (rawData.event === 'newToken') {\n            transformedData = {\n              type: 'newToken',\n              data: {\n                name: rawData.token?.name || 'Unknown',\n                address: rawData.token?.address || rawData.tokenAddress,\n                timestamp: rawData.timestamp || new Date().toISOString(),\n                initialPrice: parseFloat(rawData.token?.price || rawData.price || '0'),\n                initialLiquidity: parseFloat(rawData.token?.liquidity || rawData.liquidity || '0')\n              }\n            };\n          } else {\n            transformedData = rawData;\n          }\n\n          console.log('Transformed data:', transformedData);\n\n          // Notify all subscribers\n          this.subscribers.forEach((callback, id) => {\n            console.log(`Notifying subscriber ${id}`);\n            callback(transformedData);\n          });\n        } catch (error) {\n          console.error('Error processing WebSocket message:', error);\n          console.error('Raw message:', event.data);\n        }\n      };\n\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n        \n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'disconnected' });\n        });\n        \n        this.attemptReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket Error:', error);\n        // Notify all subscribers of connection error\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'error', error });\n        });\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to account trades:', accounts);\n    }\n  }\n\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to token trades:', tokens);\n    }\n  }\n\n  // Method to check connection status\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      subscriberCount: this.subscribers.size\n    };\n  }\n\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n    \n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    } else if (this.isConnected) {\n      // If already connected, notify the new subscriber of current status\n      callback({ type: 'connection', status: 'connected' });\n    }\n\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n    \n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}