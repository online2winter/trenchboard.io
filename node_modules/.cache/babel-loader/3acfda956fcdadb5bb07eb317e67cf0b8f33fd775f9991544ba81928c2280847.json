{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractMessageChannel = void 0;\nconst tslib_1 = require(\"tslib\");\nconst utils_1 = require(\"@trezor/utils\");\nclass AbstractMessageChannel extends utils_1.TypedEmitter {\n  constructor({\n    sendFn,\n    channel,\n    logger,\n    lazyHandshake = false,\n    legacyMode = false\n  }) {\n    super();\n    this.messagePromises = {};\n    this.messagesQueue = [];\n    this.messageID = 0;\n    this.isConnected = false;\n    this.handshakeMaxRetries = 5;\n    this.handshakeRetryInterval = 2000;\n    this.channel = channel;\n    this.sendFn = sendFn;\n    this.lazyHandshake = lazyHandshake;\n    this.legacyMode = legacyMode;\n    this.logger = logger;\n  }\n  init() {\n    if (!this.handshakeFinished) {\n      this.handshakeFinished = (0, utils_1.createDeferred)();\n      if (this.legacyMode) {\n        setTimeout(() => {\n          var _a;\n          (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve();\n        }, 500);\n      }\n      if (!this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n    }\n    return this.handshakeFinished.promise;\n  }\n  handshakeWithPeer() {\n    var _a;\n    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, 'handshake');\n    return (0, utils_1.scheduleAction)(() => tslib_1.__awaiter(this, void 0, void 0, function* () {\n      var _a;\n      this.postMessage({\n        type: 'channel-handshake-request',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      yield (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.promise;\n    }), {\n      attempts: this.handshakeMaxRetries,\n      timeout: this.handshakeRetryInterval\n    }).then(() => {\n      var _a;\n      (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, 'handshake confirmed');\n      this.messagesQueue.forEach(message => {\n        message.channel = this.channel;\n        this.sendFn(message);\n      });\n      this.messagesQueue = [];\n    }).catch(() => {\n      var _a;\n      (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.reject(new Error('handshake failed'));\n      this.handshakeFinished = undefined;\n    });\n  }\n  onMessage(_message) {\n    var _a, _b;\n    let message = _message;\n    if (this.legacyMode && message.type === undefined && 'data' in message && typeof message.data === 'object' && message.data !== null && 'type' in message.data && typeof message.data.type === 'string') {\n      message = message.data;\n    }\n    const {\n        channel,\n        id,\n        type\n      } = message,\n      data = tslib_1.__rest(message, [\"channel\", \"id\", \"type\"]);\n    if (!this.legacyMode) {\n      if (!(channel === null || channel === void 0 ? void 0 : channel.peer) || channel.peer !== this.channel.here) {\n        return;\n      }\n      if (!(channel === null || channel === void 0 ? void 0 : channel.here) || this.channel.peer !== channel.here) {\n        return;\n      }\n    }\n    if (type === 'channel-handshake-request') {\n      this.postMessage({\n        type: 'channel-handshake-confirm',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      if (this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n      return;\n    }\n    if (type === 'channel-handshake-confirm') {\n      (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve(undefined);\n      return;\n    }\n    if (this.messagePromises[id]) {\n      this.messagePromises[id].resolve(Object.assign({\n        id\n      }, data));\n      delete this.messagePromises[id];\n    }\n    const messagePromisesLength = Object.keys(this.messagePromises).length;\n    if (messagePromisesLength > 5) {\n      (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);\n    }\n    this.emit('message', message);\n  }\n  postMessage(message, {\n    usePromise = true,\n    useQueue = true\n  } = {}) {\n    message.channel = this.channel;\n    if (!usePromise) {\n      try {\n        this.sendFn(message);\n      } catch (_a) {\n        if (useQueue) {\n          this.messagesQueue.push(message);\n        }\n      }\n      return;\n    }\n    this.messageID++;\n    message.id = this.messageID;\n    this.messagePromises[message.id] = (0, utils_1.createDeferred)();\n    try {\n      this.sendFn(message);\n    } catch (_b) {\n      if (useQueue) {\n        this.messagesQueue.push(message);\n      }\n    }\n    return this.messagePromises[message.id].promise;\n  }\n  resolveMessagePromises(resolvePayload) {\n    Object.keys(this.messagePromises).forEach(id => this.messagePromises[id].resolve({\n      id,\n      payload: resolvePayload\n    }));\n  }\n  clear() {\n    this.handshakeFinished = undefined;\n  }\n}\nexports.AbstractMessageChannel = AbstractMessageChannel;","map":{"version":3,"names":["Object","defineProperty","exports","value","AbstractMessageChannel","tslib_1","require","utils_1","TypedEmitter","constructor","sendFn","channel","logger","lazyHandshake","legacyMode","messagePromises","messagesQueue","messageID","isConnected","handshakeMaxRetries","handshakeRetryInterval","init","handshakeFinished","createDeferred","setTimeout","_a","resolve","handshakeWithPeer","promise","log","here","scheduleAction","__awaiter","postMessage","type","data","success","payload","undefined","usePromise","useQueue","attempts","timeout","then","forEach","message","catch","reject","Error","onMessage","_message","_b","id","__rest","peer","assign","messagePromisesLength","keys","length","warn","emit","push","resolveMessagePromises","resolvePayload","clear"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@trezor/connect-common/lib/messageChannel/abstract.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageChannel = void 0;\nconst tslib_1 = require(\"tslib\");\nconst utils_1 = require(\"@trezor/utils\");\nclass AbstractMessageChannel extends utils_1.TypedEmitter {\n    constructor({ sendFn, channel, logger, lazyHandshake = false, legacyMode = false, }) {\n        super();\n        this.messagePromises = {};\n        this.messagesQueue = [];\n        this.messageID = 0;\n        this.isConnected = false;\n        this.handshakeMaxRetries = 5;\n        this.handshakeRetryInterval = 2000;\n        this.channel = channel;\n        this.sendFn = sendFn;\n        this.lazyHandshake = lazyHandshake;\n        this.legacyMode = legacyMode;\n        this.logger = logger;\n    }\n    init() {\n        if (!this.handshakeFinished) {\n            this.handshakeFinished = (0, utils_1.createDeferred)();\n            if (this.legacyMode) {\n                setTimeout(() => {\n                    var _a;\n                    (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve();\n                }, 500);\n            }\n            if (!this.lazyHandshake) {\n                this.handshakeWithPeer();\n            }\n        }\n        return this.handshakeFinished.promise;\n    }\n    handshakeWithPeer() {\n        var _a;\n        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, 'handshake');\n        return (0, utils_1.scheduleAction)(() => tslib_1.__awaiter(this, void 0, void 0, function* () {\n            var _a;\n            this.postMessage({\n                type: 'channel-handshake-request',\n                data: { success: true, payload: undefined },\n            }, { usePromise: false, useQueue: false });\n            yield ((_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.promise);\n        }), {\n            attempts: this.handshakeMaxRetries,\n            timeout: this.handshakeRetryInterval,\n        })\n            .then(() => {\n            var _a;\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, 'handshake confirmed');\n            this.messagesQueue.forEach(message => {\n                message.channel = this.channel;\n                this.sendFn(message);\n            });\n            this.messagesQueue = [];\n        })\n            .catch(() => {\n            var _a;\n            (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.reject(new Error('handshake failed'));\n            this.handshakeFinished = undefined;\n        });\n    }\n    onMessage(_message) {\n        var _a, _b;\n        let message = _message;\n        if (this.legacyMode &&\n            message.type === undefined &&\n            'data' in message &&\n            typeof message.data === 'object' &&\n            message.data !== null &&\n            'type' in message.data &&\n            typeof message.data.type === 'string') {\n            message = message.data;\n        }\n        const { channel, id, type } = message, data = tslib_1.__rest(message, [\"channel\", \"id\", \"type\"]);\n        if (!this.legacyMode) {\n            if (!(channel === null || channel === void 0 ? void 0 : channel.peer) || channel.peer !== this.channel.here) {\n                return;\n            }\n            if (!(channel === null || channel === void 0 ? void 0 : channel.here) || this.channel.peer !== channel.here) {\n                return;\n            }\n        }\n        if (type === 'channel-handshake-request') {\n            this.postMessage({\n                type: 'channel-handshake-confirm',\n                data: { success: true, payload: undefined },\n            }, { usePromise: false, useQueue: false });\n            if (this.lazyHandshake) {\n                this.handshakeWithPeer();\n            }\n            return;\n        }\n        if (type === 'channel-handshake-confirm') {\n            (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve(undefined);\n            return;\n        }\n        if (this.messagePromises[id]) {\n            this.messagePromises[id].resolve(Object.assign({ id }, data));\n            delete this.messagePromises[id];\n        }\n        const messagePromisesLength = Object.keys(this.messagePromises).length;\n        if (messagePromisesLength > 5) {\n            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);\n        }\n        this.emit('message', message);\n    }\n    postMessage(message, { usePromise = true, useQueue = true } = {}) {\n        message.channel = this.channel;\n        if (!usePromise) {\n            try {\n                this.sendFn(message);\n            }\n            catch (_a) {\n                if (useQueue) {\n                    this.messagesQueue.push(message);\n                }\n            }\n            return;\n        }\n        this.messageID++;\n        message.id = this.messageID;\n        this.messagePromises[message.id] = (0, utils_1.createDeferred)();\n        try {\n            this.sendFn(message);\n        }\n        catch (_b) {\n            if (useQueue) {\n                this.messagesQueue.push(message);\n            }\n        }\n        return this.messagePromises[message.id].promise;\n    }\n    resolveMessagePromises(resolvePayload) {\n        Object.keys(this.messagePromises).forEach(id => this.messagePromises[id].resolve({\n            id,\n            payload: resolvePayload,\n        }));\n    }\n    clear() {\n        this.handshakeFinished = undefined;\n    }\n}\nexports.AbstractMessageChannel = AbstractMessageChannel;\n//# sourceMappingURL=abstract.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}