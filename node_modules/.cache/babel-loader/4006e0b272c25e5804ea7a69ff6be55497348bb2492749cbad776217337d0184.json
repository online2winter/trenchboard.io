{"ast":null,"code":"import { Connection, PublicKey } from '@solana/web3.js';\n\n// Using Helius RPC endpoint which has higher rate limits\nconst SOLANA_RPC_URL = 'https://rpc.helius.xyz/?api-key=YOUR_API_KEY';\n// Fallback to public endpoint if needed\nconst FALLBACK_RPC_URL = 'https://api.mainnet-beta.solana.com';\nlet connection = new Connection(SOLANA_RPC_URL);\n\n// Jupiter API for price data\nconst JUPITER_API_URL = 'https://price.jup.ag/v4/price';\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst fetchWithRetry = async (url, options = {}, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (response.status === 403) {\n        throw new Error('Rate limit exceeded');\n      }\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      await delay(1000 * Math.pow(2, i)); // Exponential backoff\n    }\n  }\n};\nexport const fetchTokenData = async tokenAddress => {\n  try {\n    var _priceData$data$token;\n    const tokenPublicKey = new PublicKey(tokenAddress);\n\n    // Get token supply with retry logic\n    let tokenSupply;\n    try {\n      tokenSupply = await connection.getTokenSupply(tokenPublicKey);\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        tokenSupply = await connection.getTokenSupply(tokenPublicKey);\n      } else {\n        throw error;\n      }\n    }\n\n    // Get price from Jupiter with retry\n    const priceData = await fetchWithRetry(`${JUPITER_API_URL}?ids=${tokenAddress}`);\n    const price = ((_priceData$data$token = priceData.data[tokenAddress]) === null || _priceData$data$token === void 0 ? void 0 : _priceData$data$token.price) || 0;\n\n    // Get 24h volume (this would need a proper DEX API in production)\n    const volume24h = await getToken24hVolume(tokenAddress);\n    return {\n      price,\n      volume24h,\n      supply: tokenSupply.value.uiAmount,\n      priceChange24h: await getToken24hPriceChange(tokenAddress)\n    };\n  } catch (error) {\n    console.error('Error fetching token data:', error);\n    throw error;\n  }\n};\nexport const getWalletBalance = async walletAddress => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    let balance;\n    try {\n      balance = await connection.getBalance(publicKey);\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        balance = await connection.getBalance(publicKey);\n      } else {\n        throw error;\n      }\n    }\n    return balance / 1e9; // Convert lamports to SOL\n  } catch (error) {\n    console.error('Error fetching wallet balance:', error);\n    throw error;\n  }\n};\nexport const getTokenAccounts = async walletAddress => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    let tokenAccounts;\n    try {\n      tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, {\n        programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')\n      });\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, {\n          programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')\n        });\n      } else {\n        throw error;\n      }\n    }\n    return tokenAccounts.value;\n  } catch (error) {\n    console.error('Error fetching token accounts:', error);\n    throw error;\n  }\n};\n\n// Helper function to get 24h volume (mock implementation)\nconst getToken24hVolume = async tokenAddress => {\n  // In a real implementation, you would:\n  // 1. Query DEX APIs (e.g., Raydium, Orca)\n  // 2. Aggregate volume across different DEXes\n  // 3. Return total 24h volume\n  return Math.random() * 1000000; // Mock data\n};\n\n// Helper function to get 24h price change (mock implementation)\nconst getToken24hPriceChange = async tokenAddress => {\n  // In a real implementation, you would:\n  // 1. Get current price\n  // 2. Get price from 24h ago\n  // 3. Calculate percentage change\n  return (Math.random() - 0.5) * 20; // Mock data: -10% to +10%\n};","map":{"version":3,"names":["Connection","PublicKey","SOLANA_RPC_URL","FALLBACK_RPC_URL","connection","JUPITER_API_URL","delay","ms","Promise","resolve","setTimeout","fetchWithRetry","url","options","retries","i","response","fetch","status","Error","ok","json","error","Math","pow","fetchTokenData","tokenAddress","_priceData$data$token","tokenPublicKey","tokenSupply","getTokenSupply","message","includes","priceData","price","data","volume24h","getToken24hVolume","supply","value","uiAmount","priceChange24h","getToken24hPriceChange","console","getWalletBalance","walletAddress","publicKey","balance","getBalance","getTokenAccounts","tokenAccounts","getParsedTokenAccountsByOwner","programId","random"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/src/utils/api.js"],"sourcesContent":["import { Connection, PublicKey } from '@solana/web3.js';\n\n// Using Helius RPC endpoint which has higher rate limits\nconst SOLANA_RPC_URL = 'https://rpc.helius.xyz/?api-key=YOUR_API_KEY';\n// Fallback to public endpoint if needed\nconst FALLBACK_RPC_URL = 'https://api.mainnet-beta.solana.com';\n\nlet connection = new Connection(SOLANA_RPC_URL);\n\n// Jupiter API for price data\nconst JUPITER_API_URL = 'https://price.jup.ag/v4/price';\n\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst fetchWithRetry = async (url, options = {}, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (response.status === 403) {\n        throw new Error('Rate limit exceeded');\n      }\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      await delay(1000 * Math.pow(2, i)); // Exponential backoff\n    }\n  }\n};\n\nexport const fetchTokenData = async (tokenAddress) => {\n  try {\n    const tokenPublicKey = new PublicKey(tokenAddress);\n    \n    // Get token supply with retry logic\n    let tokenSupply;\n    try {\n      tokenSupply = await connection.getTokenSupply(tokenPublicKey);\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        tokenSupply = await connection.getTokenSupply(tokenPublicKey);\n      } else {\n        throw error;\n      }\n    }\n    \n    // Get price from Jupiter with retry\n    const priceData = await fetchWithRetry(`${JUPITER_API_URL}?ids=${tokenAddress}`);\n    const price = priceData.data[tokenAddress]?.price || 0;\n\n    // Get 24h volume (this would need a proper DEX API in production)\n    const volume24h = await getToken24hVolume(tokenAddress);\n\n    return {\n      price,\n      volume24h,\n      supply: tokenSupply.value.uiAmount,\n      priceChange24h: await getToken24hPriceChange(tokenAddress),\n    };\n  } catch (error) {\n    console.error('Error fetching token data:', error);\n    throw error;\n  }\n};\n\nexport const getWalletBalance = async (walletAddress) => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    let balance;\n    try {\n      balance = await connection.getBalance(publicKey);\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        balance = await connection.getBalance(publicKey);\n      } else {\n        throw error;\n      }\n    }\n    return balance / 1e9; // Convert lamports to SOL\n  } catch (error) {\n    console.error('Error fetching wallet balance:', error);\n    throw error;\n  }\n};\n\nexport const getTokenAccounts = async (walletAddress) => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    let tokenAccounts;\n    try {\n      tokenAccounts = await connection.getParsedTokenAccountsByOwner(\n        publicKey,\n        {\n          programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),\n        }\n      );\n    } catch (error) {\n      if (error.message.includes('429') || error.message.includes('403')) {\n        // Fallback to public endpoint if rate limited\n        connection = new Connection(FALLBACK_RPC_URL);\n        tokenAccounts = await connection.getParsedTokenAccountsByOwner(\n          publicKey,\n          {\n            programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),\n          }\n        );\n      } else {\n        throw error;\n      }\n    }\n    return tokenAccounts.value;\n  } catch (error) {\n    console.error('Error fetching token accounts:', error);\n    throw error;\n  }\n};\n\n// Helper function to get 24h volume (mock implementation)\nconst getToken24hVolume = async (tokenAddress) => {\n  // In a real implementation, you would:\n  // 1. Query DEX APIs (e.g., Raydium, Orca)\n  // 2. Aggregate volume across different DEXes\n  // 3. Return total 24h volume\n  return Math.random() * 1000000; // Mock data\n};\n\n// Helper function to get 24h price change (mock implementation)\nconst getToken24hPriceChange = async (tokenAddress) => {\n  // In a real implementation, you would:\n  // 1. Get current price\n  // 2. Get price from 24h ago\n  // 3. Calculate percentage change\n  return (Math.random() - 0.5) * 20; // Mock data: -10% to +10%\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}