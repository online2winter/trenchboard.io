{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as Rt, TRANSPORT_TYPES as f, EVENT_CLIENT_SESSION_TRACES as C, EVENT_CLIENT_SESSION_ERRORS as F, EVENT_CLIENT_AUTHENTICATE_TRACES as Q, EVENT_CLIENT_AUTHENTICATE_ERRORS as se, EVENT_CLIENT_PAIRING_ERRORS as St, EVENT_CLIENT_PAIRING_TRACES as It, RELAYER_EVENTS as Ge, VERIFY_SERVER as ft, EXPIRER_EVENTS as vt, PAIRING_EVENTS as je, Store as Y, Core as qt } from \"@walletconnect/core\";\nimport { pino as Tt, getDefaultLoggerOptions as Nt, generateChildLogger as Pt, getLoggerContext as Ot } from \"@walletconnect/logger\";\nimport { IEngine as At, ISignClient as bt } from \"@walletconnect/types\";\nimport { THIRTY_DAYS as Ct, SEVEN_DAYS as Fe, FIVE_MINUTES as A, ONE_DAY as k, ONE_HOUR as Qe, ONE_SECOND as ze, toMiliseconds as Te } from \"@walletconnect/time\";\nimport { getInternalError as u, calcExpiry as b, createDelayedPromise as X, engineEvent as g, getSdkError as P, getDeepLink as xt, handleDeeplinkRedirect as Lt, isSessionCompatible as Dt, hashKey as Ne, parseChainId as Pe, createEncodedRecap as Vt, getRecapFromResources as Oe, mergeEncodedRecaps as Mt, TYPE_2 as kt, BASE64URL as ie, getLinkModeURL as he, validateSignedCacao as He, getNamespacedDidChainId as Ye, getDidAddress as Xe, getMethodsFromRecap as Je, getChainsFromRecap as Be, buildNamespacesFromAuth as We, formatMessage as $t, BASE64 as de, hashMessage as J, isExpired as B, MemoryStore as re, isValidParams as x, isUndefined as ne, isValidRelays as Kt, isValidObject as Ze, isValidRequiredNamespaces as Ut, isValidNamespaces as Ae, isConformingNamespaces as et, isValidString as $, isValidErrorReason as Gt, isValidRelay as jt, isValidController as Ft, isValidNamespacesChainId as tt, isValidRequest as Qt, isValidNamespacesRequest as zt, isValidRequestExpiry as Ht, isValidResponse as Yt, isValidEvent as Xt, isValidNamespacesEvent as Jt, getSearchParamFromURL as st, isTestRun as Bt, isReactNative as Wt, parseExpirerTarget as Zt, isValidId as es, TYPE_1 as be, getAppMetadata as ts } from \"@walletconnect/utils\";\nimport ss, { EventEmitter as is } from \"events\";\nimport { payloadId as z, getBigIntRpcId as ue, isJsonRpcResult as K, isJsonRpcError as U, formatJsonRpcRequest as ge, formatJsonRpcResult as rs, formatJsonRpcError as ns, isJsonRpcRequest as os, isJsonRpcResponse as as } from \"@walletconnect/jsonrpc-utils\";\nconst Ce = \"wc\",\n  xe = 2,\n  Le = \"client\",\n  ye = `${Ce}@${xe}:${Le}:`,\n  we = {\n    name: Le,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.org\"\n  },\n  cs = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\"\n  },\n  ls = {\n    database: \":memory:\"\n  },\n  De = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ps = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  hs = \"history\",\n  ds = \"0.3\",\n  it = \"proposal\",\n  us = Ct,\n  rt = \"Proposal expired\",\n  nt = \"session\",\n  H = Fe,\n  ot = \"engine\",\n  v = {\n    wc_sessionPropose: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: A,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: Qe,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: Qe,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  me = {\n    min: A,\n    max: Fe\n  },\n  L = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  at = \"request\",\n  ct = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"],\n  lt = \"wc\",\n  gs = 1.5,\n  pt = \"auth\",\n  ht = \"authKeys\",\n  dt = \"pairingTopics\",\n  ut = \"requests\",\n  oe = `${lt}@${1.5}:${pt}:`,\n  ae = `${oe}:PUB_KEY`;\nvar ys = Object.defineProperty,\n  ws = Object.defineProperties,\n  ms = Object.getOwnPropertyDescriptors,\n  gt = Object.getOwnPropertySymbols,\n  _s = Object.prototype.hasOwnProperty,\n  Es = Object.prototype.propertyIsEnumerable,\n  yt = (q, o, e) => o in q ? ys(q, o, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : q[o] = e,\n  I = (q, o) => {\n    for (var e in o || (o = {})) _s.call(o, e) && yt(q, e, o[e]);\n    if (gt) for (var e of gt(o)) Es.call(o, e) && yt(q, e, o[e]);\n    return q;\n  },\n  D = (q, o) => ws(q, ms(o));\nclass Rs extends At {\n  constructor(o) {\n    super(o), this.name = ot, this.events = new ss(), this.initialized = !1, this.requestQueue = {\n      state: L.idle,\n      queue: []\n    }, this.sessionRequestQueue = {\n      state: L.idle,\n      queue: []\n    }, this.requestQueueDelay = ze, this.expectedPairingMethodMap = new Map(), this.recentlyDeletedMap = new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({\n        methods: Object.keys(v)\n      }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Te(this.requestQueueDelay)));\n    }, this.connect = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const t = D(I({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(t);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: n,\n        relays: a\n      } = t;\n      let c = s,\n        h,\n        p = !1;\n      try {\n        if (c) {\n          const E = this.client.core.pairing.pairings.get(c);\n          this.client.logger.warn(\"connect() with existing pairing topic is deprecated and will be removed in the next major release.\"), p = E.active;\n        }\n      } catch (E) {\n        throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`), E;\n      }\n      if (!c || !p) {\n        const {\n          topic: E,\n          uri: S\n        } = await this.client.core.pairing.create();\n        c = E, h = S;\n      }\n      if (!c) {\n        const {\n          message: E\n        } = u(\"NO_MATCHING_KEY\", `connect() pairing topic: ${c}`);\n        throw new Error(E);\n      }\n      const d = await this.client.core.crypto.generateKeyPair(),\n        l = v.wc_sessionPropose.req.ttl || A,\n        w = b(l),\n        m = I({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: a ?? [{\n            protocol: Rt\n          }],\n          proposer: {\n            publicKey: d,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: w,\n          pairingTopic: c\n        }, n && {\n          sessionProperties: n\n        }),\n        {\n          reject: y,\n          resolve: _,\n          done: R\n        } = X(l, rt);\n      this.events.once(g(\"session_connect\"), async ({\n        error: E,\n        session: S\n      }) => {\n        if (E) y(E);else if (S) {\n          S.self.publicKey = d;\n          const M = D(I({}, S), {\n            pairingTopic: m.pairingTopic,\n            requiredNamespaces: m.requiredNamespaces,\n            optionalNamespaces: m.optionalNamespaces,\n            transportType: f.relay\n          });\n          await this.client.session.set(S.topic, M), await this.setExpiry(S.topic, S.expiry), c && (await this.client.core.pairing.updateMetadata({\n            topic: c,\n            metadata: S.peer.metadata\n          })), this.cleanupDuplicatePairings(M), _(M);\n        }\n      });\n      const V = await this.sendRequest({\n        topic: c,\n        method: \"wc_sessionPropose\",\n        params: m,\n        throwOnFailedPublish: !0\n      });\n      return await this.setProposal(V, I({\n        id: V\n      }, m)), {\n        uri: h,\n        approval: R\n      };\n    }, this.pair = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(e);\n      } catch (t) {\n        throw this.client.logger.error(\"pair() failed\"), t;\n      }\n    }, this.approve = async e => {\n      var t, s, i;\n      const r = this.client.core.eventClient.createEvent({\n        properties: {\n          topic: (t = e?.id) == null ? void 0 : t.toString(),\n          trace: [C.session_approve_started]\n        }\n      });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (N) {\n        throw r.setError(F.no_internet_connection), N;\n      }\n      try {\n        await this.isValidProposalId(e?.id);\n      } catch (N) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(F.proposal_not_found), N;\n      }\n      try {\n        await this.isValidApprove(e);\n      } catch (N) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), r.setError(F.session_approve_namespace_validation_failure), N;\n      }\n      const {\n          id: n,\n          relayProtocol: a,\n          namespaces: c,\n          sessionProperties: h,\n          sessionConfig: p\n        } = e,\n        d = this.client.proposal.get(n);\n      this.client.core.eventClient.deleteEvent({\n        eventId: r.eventId\n      });\n      const {\n        pairingTopic: l,\n        proposer: w,\n        requiredNamespaces: m,\n        optionalNamespaces: y\n      } = d;\n      let _ = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({\n        topic: l\n      });\n      _ || (_ = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({\n        type: C.session_approve_started,\n        properties: {\n          topic: l,\n          trace: [C.session_approve_started, C.session_namespaces_validation_success]\n        }\n      }));\n      const R = await this.client.core.crypto.generateKeyPair(),\n        V = w.publicKey,\n        E = await this.client.core.crypto.generateSharedKey(R, V),\n        S = I(I({\n          relay: {\n            protocol: a ?? \"irn\"\n          },\n          namespaces: c,\n          controller: {\n            publicKey: R,\n            metadata: this.client.metadata\n          },\n          expiry: b(H)\n        }, h && {\n          sessionProperties: h\n        }), p && {\n          sessionConfig: p\n        }),\n        M = f.relay;\n      _.addTrace(C.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe(E, {\n          transportType: M\n        });\n      } catch (N) {\n        throw _.setError(F.subscribe_session_topic_failure), N;\n      }\n      _.addTrace(C.subscribe_session_topic_success);\n      const W = D(I({}, S), {\n        topic: E,\n        requiredNamespaces: m,\n        optionalNamespaces: y,\n        pairingTopic: l,\n        acknowledged: !1,\n        self: S.controller,\n        peer: {\n          publicKey: w.publicKey,\n          metadata: w.metadata\n        },\n        controller: R,\n        transportType: f.relay\n      });\n      await this.client.session.set(E, W), _.addTrace(C.store_session);\n      try {\n        _.addTrace(C.publishing_session_settle), await this.sendRequest({\n          topic: E,\n          method: \"wc_sessionSettle\",\n          params: S,\n          throwOnFailedPublish: !0\n        }).catch(N => {\n          throw _?.setError(F.session_settle_publish_failure), N;\n        }), _.addTrace(C.session_settle_publish_success), _.addTrace(C.publishing_session_approve), await this.sendResult({\n          id: n,\n          topic: l,\n          result: {\n            relay: {\n              protocol: a ?? \"irn\"\n            },\n            responderPublicKey: R\n          },\n          throwOnFailedPublish: !0\n        }).catch(N => {\n          throw _?.setError(F.session_approve_publish_failure), N;\n        }), _.addTrace(C.session_approve_publish_success);\n      } catch (N) {\n        throw this.client.logger.error(N), this.client.session.delete(E, P(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(E), N;\n      }\n      return this.client.core.eventClient.deleteEvent({\n        eventId: _.eventId\n      }), await this.client.core.pairing.updateMetadata({\n        topic: l,\n        metadata: w.metadata\n      }), await this.client.proposal.delete(n, P(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: l\n      }), await this.setExpiry(E, b(H)), {\n        topic: E,\n        acknowledged: () => Promise.resolve(this.client.session.get(E))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(e);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      let i;\n      try {\n        i = this.client.proposal.get(t).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: t,\n        topic: i,\n        error: s,\n        rpcOpts: v.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(t, P(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(e);\n      } catch (p) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), p;\n      }\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        {\n          done: i,\n          resolve: r,\n          reject: n\n        } = X(),\n        a = z(),\n        c = ue().toString(),\n        h = this.client.session.get(t).namespaces;\n      return this.events.once(g(\"session_update\", a), ({\n        error: p\n      }) => {\n        p ? n(p) : r();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: c\n      }).catch(p => {\n        this.client.logger.error(p), this.client.session.update(t, {\n          namespaces: h\n        }), n(p);\n      }), {\n        acknowledged: i\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(e);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: t\n        } = e,\n        s = z(),\n        {\n          done: i,\n          resolve: r,\n          reject: n\n        } = X();\n      return this.events.once(g(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? n(a) : r();\n      }), await this.setExpiry(t, b(H)), this.sendRequest({\n        topic: t,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        n(a);\n      }), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(e);\n      } catch (w) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), w;\n      }\n      const {\n          chainId: t,\n          request: s,\n          topic: i,\n          expiry: r = v.wc_sessionRequest.req.ttl\n        } = e,\n        n = this.client.session.get(i);\n      n?.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const a = z(),\n        c = ue().toString(),\n        {\n          done: h,\n          resolve: p,\n          reject: d\n        } = X(r, \"Request expired. Please try again.\");\n      this.events.once(g(\"session_request\", a), ({\n        error: w,\n        result: m\n      }) => {\n        w ? d(w) : p(m);\n      });\n      const l = this.getAppLinkIfEnabled(n.peer.metadata, n.transportType);\n      return l ? (await this.sendRequest({\n        clientRpcId: a,\n        relayRpcId: c,\n        topic: i,\n        method: \"wc_sessionRequest\",\n        params: {\n          request: D(I({}, s), {\n            expiryTimestamp: b(r)\n          }),\n          chainId: t\n        },\n        expiry: r,\n        throwOnFailedPublish: !0,\n        appLink: l\n      }).catch(w => d(w)), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: s,\n        chainId: t,\n        id: a\n      }), await h()) : await Promise.all([new Promise(async w => {\n        await this.sendRequest({\n          clientRpcId: a,\n          relayRpcId: c,\n          topic: i,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: D(I({}, s), {\n              expiryTimestamp: b(r)\n            }),\n            chainId: t\n          },\n          expiry: r,\n          throwOnFailedPublish: !0\n        }).catch(m => d(m)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: t,\n          id: a\n        }), w();\n      }), new Promise(async w => {\n        var m;\n        if (!((m = n.sessionConfig) != null && m.disableDeepLink)) {\n          const y = await xt(this.client.core.storage, De);\n          await Lt({\n            id: a,\n            topic: i,\n            wcDeepLink: y\n          });\n        }\n        w();\n      }), h()]).then(w => w[2]);\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: i\n        } = s,\n        r = this.client.session.get(t);\n      r.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const n = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);\n      K(s) ? await this.sendResult({\n        id: i,\n        topic: t,\n        result: s.result,\n        throwOnFailedPublish: !0,\n        appLink: n\n      }) : U(s) && (await this.sendError({\n        id: i,\n        topic: t,\n        error: s.error,\n        appLink: n\n      })), this.cleanupAfterResponse(e);\n    }, this.ping = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(e);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = z(),\n          i = ue().toString(),\n          {\n            done: r,\n            resolve: n,\n            reject: a\n          } = X();\n        this.events.once(g(\"session_ping\", s), ({\n          error: c\n        }) => {\n          c ? a(c) : n();\n        }), await Promise.all([this.sendRequest({\n          topic: t,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn(\"ping() on pairing topic is deprecated and will be removed in the next major release.\"), await this.client.core.pairing.ping({\n        topic: t\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);\n      const {\n          topic: t,\n          event: s,\n          chainId: i\n        } = e,\n        r = ue().toString(),\n        n = z();\n      await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r,\n        clientRpcId: n\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionDelete\",\n        params: P(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: t,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({\n        topic: t\n      });else {\n        const {\n          message: s\n        } = u(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${t}`);\n        throw new Error(s);\n      }\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(t => Dt(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {\n      var s;\n      this.isInitialized(), this.isValidAuthenticate(e);\n      const i = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),\n        r = i ? f.link_mode : f.relay;\n      r === f.relay && (await this.confirmOnlineStateOrThrow());\n      const {\n          chains: n,\n          statement: a = \"\",\n          uri: c,\n          domain: h,\n          nonce: p,\n          type: d,\n          exp: l,\n          nbf: w,\n          methods: m = [],\n          expiry: y\n        } = e,\n        _ = [...(e.resources || [])],\n        {\n          topic: R,\n          uri: V\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"],\n          transportType: r\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: R,\n          uri: V\n        }\n      });\n      const E = await this.client.core.crypto.generateKeyPair(),\n        S = Ne(E);\n      if (await Promise.all([this.client.auth.authKeys.set(ae, {\n        responseTopic: S,\n        publicKey: E\n      }), this.client.auth.pairingTopics.set(S, {\n        topic: S,\n        pairingTopic: R\n      })]), await this.client.core.relayer.subscribe(S, {\n        transportType: r\n      }), this.client.logger.info(`sending request to new pairing topic: ${R}`), m.length > 0) {\n        const {\n          namespace: O\n        } = Pe(n[0]);\n        let T = Vt(O, \"request\", m);\n        Oe(_) && (T = Mt(T, _.pop())), _.push(T);\n      }\n      const M = y && y > v.wc_sessionAuthenticate.req.ttl ? y : v.wc_sessionAuthenticate.req.ttl,\n        W = {\n          authPayload: {\n            type: d ?? \"caip122\",\n            chains: n,\n            statement: a,\n            aud: c,\n            domain: h,\n            version: \"1\",\n            nonce: p,\n            iat: new Date().toISOString(),\n            exp: l,\n            nbf: w,\n            resources: _\n          },\n          requester: {\n            publicKey: E,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: b(M)\n        },\n        N = {\n          eip155: {\n            chains: n,\n            methods: [...new Set([\"personal_sign\", ...m])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        Ve = {\n          requiredNamespaces: {},\n          optionalNamespaces: N,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: R,\n          proposer: {\n            publicKey: E,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: b(v.wc_sessionPropose.req.ttl)\n        },\n        {\n          done: mt,\n          resolve: Me,\n          reject: Ee\n        } = X(M, \"Request expired\"),\n        ce = async ({\n          error: O,\n          session: T\n        }) => {\n          if (this.events.off(g(\"session_request\", G), Re), O) Ee(O);else if (T) {\n            T.self.publicKey = E, await this.client.session.set(T.topic, T), await this.setExpiry(T.topic, T.expiry), R && (await this.client.core.pairing.updateMetadata({\n              topic: R,\n              metadata: T.peer.metadata\n            }));\n            const le = this.client.session.get(T.topic);\n            await this.deleteProposal(Z), Me({\n              session: le\n            });\n          }\n        },\n        Re = async O => {\n          var T, le, ke;\n          if (await this.deletePendingAuthRequest(G, {\n            message: \"fulfilled\",\n            code: 0\n          }), O.error) {\n            const te = P(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return O.error.code === te.code ? void 0 : (this.events.off(g(\"session_connect\"), ce), Ee(O.error.message));\n          }\n          await this.deleteProposal(Z), this.events.off(g(\"session_connect\"), ce);\n          const {\n              cacaos: $e,\n              responder: j\n            } = O.result,\n            Ie = [],\n            Ke = [];\n          for (const te of $e) {\n            (await He({\n              cacao: te,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(te, \"Signature verification failed\"), Ee(P(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: fe\n              } = te,\n              ve = Oe(fe.resources),\n              Ue = [Ye(fe.iss)],\n              _t = Xe(fe.iss);\n            if (ve) {\n              const qe = Je(ve),\n                Et = Be(ve);\n              Ie.push(...qe), Ue.push(...Et);\n            }\n            for (const qe of Ue) Ke.push(`${qe}:${_t}`);\n          }\n          const ee = await this.client.core.crypto.generateSharedKey(E, j.publicKey);\n          let pe;\n          Ie.length > 0 && (pe = {\n            topic: ee,\n            acknowledged: !0,\n            self: {\n              publicKey: E,\n              metadata: this.client.metadata\n            },\n            peer: j,\n            controller: j.publicKey,\n            expiry: b(H),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: R,\n            namespaces: We([...new Set(Ie)], [...new Set(Ke)]),\n            transportType: r\n          }, await this.client.core.relayer.subscribe(ee, {\n            transportType: r\n          }), await this.client.session.set(ee, pe), R && (await this.client.core.pairing.updateMetadata({\n            topic: R,\n            metadata: j.metadata\n          })), pe = this.client.session.get(ee)), (T = this.client.metadata.redirect) != null && T.linkMode && (le = j.metadata.redirect) != null && le.linkMode && (ke = j.metadata.redirect) != null && ke.universal && t && (this.client.core.addLinkModeSupportedApp(j.metadata.redirect.universal), this.client.session.update(ee, {\n            transportType: f.link_mode\n          })), Me({\n            auths: $e,\n            session: pe\n          });\n        },\n        G = z(),\n        Z = z();\n      this.events.once(g(\"session_connect\"), ce), this.events.once(g(\"session_request\", G), Re);\n      let Se;\n      try {\n        if (i) {\n          const O = ge(\"wc_sessionAuthenticate\", W, G);\n          this.client.core.history.set(R, O);\n          const T = await this.client.core.crypto.encode(\"\", O, {\n            type: kt,\n            encoding: ie\n          });\n          Se = he(t, R, T);\n        } else await Promise.all([this.sendRequest({\n          topic: R,\n          method: \"wc_sessionAuthenticate\",\n          params: W,\n          expiry: e.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: G\n        }), this.sendRequest({\n          topic: R,\n          method: \"wc_sessionPropose\",\n          params: Ve,\n          expiry: v.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: Z\n        })]);\n      } catch (O) {\n        throw this.events.off(g(\"session_connect\"), ce), this.events.off(g(\"session_request\", G), Re), O;\n      }\n      return await this.setProposal(Z, I({\n        id: Z\n      }, Ve)), await this.setAuthRequest(G, {\n        request: D(I({}, W), {\n          verifyContext: {}\n        }),\n        pairingTopic: R,\n        transportType: r\n      }), {\n        uri: Se ?? V,\n        response: mt\n      };\n    }, this.approveSessionAuthenticate = async e => {\n      const {\n          id: t,\n          auths: s\n        } = e,\n        i = this.client.core.eventClient.createEvent({\n          properties: {\n            topic: t.toString(),\n            trace: [Q.authenticated_session_approve_started]\n          }\n        });\n      try {\n        this.isInitialized();\n      } catch (y) {\n        throw i.setError(se.no_internet_connection), y;\n      }\n      const r = this.getPendingAuthRequest(t);\n      if (!r) throw i.setError(se.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);\n      const n = r.transportType || f.relay;\n      n === f.relay && (await this.confirmOnlineStateOrThrow());\n      const a = r.requester.publicKey,\n        c = await this.client.core.crypto.generateKeyPair(),\n        h = Ne(a),\n        p = {\n          type: be,\n          receiverPublicKey: a,\n          senderPublicKey: c\n        },\n        d = [],\n        l = [];\n      for (const y of s) {\n        if (!(await He({\n          cacao: y,\n          projectId: this.client.core.projectId\n        }))) {\n          i.setError(se.invalid_cacao);\n          const S = P(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: t,\n            topic: h,\n            error: S,\n            encodeOpts: p\n          }), new Error(S.message);\n        }\n        i.addTrace(Q.cacaos_verified);\n        const {\n            p: _\n          } = y,\n          R = Oe(_.resources),\n          V = [Ye(_.iss)],\n          E = Xe(_.iss);\n        if (R) {\n          const S = Je(R),\n            M = Be(R);\n          d.push(...S), V.push(...M);\n        }\n        for (const S of V) l.push(`${S}:${E}`);\n      }\n      const w = await this.client.core.crypto.generateSharedKey(c, a);\n      i.addTrace(Q.create_authenticated_session_topic);\n      let m;\n      if (d?.length > 0) {\n        m = {\n          topic: w,\n          acknowledged: !0,\n          self: {\n            publicKey: c,\n            metadata: this.client.metadata\n          },\n          peer: {\n            publicKey: a,\n            metadata: r.requester.metadata\n          },\n          controller: a,\n          expiry: b(H),\n          authentication: s,\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: {\n            protocol: \"irn\"\n          },\n          pairingTopic: r.pairingTopic,\n          namespaces: We([...new Set(d)], [...new Set(l)]),\n          transportType: n\n        }, i.addTrace(Q.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(w, {\n            transportType: n\n          });\n        } catch (y) {\n          throw i.setError(se.subscribe_authenticated_session_topic_failure), y;\n        }\n        i.addTrace(Q.subscribe_authenticated_session_topic_success), await this.client.session.set(w, m), i.addTrace(Q.store_authenticated_session), await this.client.core.pairing.updateMetadata({\n          topic: r.pairingTopic,\n          metadata: r.requester.metadata\n        });\n      }\n      i.addTrace(Q.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({\n          topic: h,\n          id: t,\n          result: {\n            cacaos: s,\n            responder: {\n              publicKey: c,\n              metadata: this.client.metadata\n            }\n          },\n          encodeOpts: p,\n          throwOnFailedPublish: !0,\n          appLink: this.getAppLinkIfEnabled(r.requester.metadata, n)\n        });\n      } catch (y) {\n        throw i.setError(se.authenticated_session_approve_publish_failure), y;\n      }\n      return await this.client.auth.requests.delete(t, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: r.pairingTopic\n      }), this.client.core.eventClient.deleteEvent({\n        eventId: i.eventId\n      }), {\n        session: m\n      };\n    }, this.rejectSessionAuthenticate = async e => {\n      this.isInitialized();\n      const {\n          id: t,\n          reason: s\n        } = e,\n        i = this.getPendingAuthRequest(t);\n      if (!i) throw new Error(`Could not find pending auth request with id ${t}`);\n      i.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const r = i.requester.publicKey,\n        n = await this.client.core.crypto.generateKeyPair(),\n        a = Ne(r),\n        c = {\n          type: be,\n          receiverPublicKey: r,\n          senderPublicKey: n\n        };\n      await this.sendError({\n        id: t,\n        topic: a,\n        error: s,\n        encodeOpts: c,\n        rpcOpts: v.wc_sessionAuthenticate.reject,\n        appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)\n      }), await this.client.auth.requests.delete(t, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(t, P(\"USER_DISCONNECTED\"));\n    }, this.formatAuthMessage = e => {\n      this.isInitialized();\n      const {\n        request: t,\n        iss: s\n      } = e;\n      return $t(t, s);\n    }, this.processRelayMessageCache = () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {\n          const e = this.relayMessageCache.shift();\n          e && (await this.onRelayMessage(e));\n        } catch (e) {\n          this.client.logger.error(e);\n        }\n      }, 50);\n    }, this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const t = this.client.core.pairing.pairings.get(e.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, n;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((n = i.peerMetadata) == null ? void 0 : n.url) === e.peer.metadata.url && i.topic && i.topic !== t.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }, this.deleteSession = async e => {\n      var t;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: n = 0\n        } = e,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, P(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(De).catch(c => this.client.logger.warn(c)), this.getPendingSessionRequests().forEach(c => {\n        c.topic === s && this.deletePendingSessionRequest(c.id, P(\"USER_DISCONNECTED\"));\n      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = L.idle), r && this.client.events.emit(\"session_delete\", {\n        id: n,\n        topic: s\n      });\n    }, this.deleteProposal = async (e, t) => {\n      if (t) try {\n        const s = this.client.proposal.get(e),\n          i = this.client.core.eventClient.getEvent({\n            topic: s.pairingTopic\n          });\n        i?.setError(F.proposal_expired);\n      } catch {}\n      await Promise.all([this.client.proposal.delete(e, P(\"USER_DISCONNECTED\")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"proposal\");\n    }, this.deletePendingSessionRequest = async (e, t, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), s && (this.sessionRequestQueue.state = L.idle, this.client.events.emit(\"session_request_expire\", {\n        id: e\n      }));\n    }, this.deletePendingAuthRequest = async (e, t, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, t) => {\n      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, {\n        expiry: t\n      }));\n    }, this.setProposal = async (e, t) => {\n      this.client.core.expirer.set(e, b(v.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);\n    }, this.setAuthRequest = async (e, t) => {\n      const {\n        request: s,\n        pairingTopic: i,\n        transportType: r = f.relay\n      } = t;\n      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: e,\n        pairingTopic: i,\n        verifyContext: s.verifyContext,\n        transportType: r\n      });\n    }, this.setPendingSessionRequest = async e => {\n      const {\n          id: t,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = e,\n        n = i.request.expiryTimestamp || b(v.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(t, n), await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }, this.sendRequest = async e => {\n      const {\n          topic: t,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: n,\n          clientRpcId: a,\n          throwOnFailedPublish: c,\n          appLink: h\n        } = e,\n        p = ge(s, i, a);\n      let d;\n      const l = !!h;\n      try {\n        const y = l ? ie : de;\n        d = await this.client.core.crypto.encode(t, p, {\n          encoding: y\n        });\n      } catch (y) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y;\n      }\n      let w;\n      if (ct.includes(s)) {\n        const y = J(JSON.stringify(p)),\n          _ = J(d);\n        w = await this.client.core.verify.register({\n          id: _,\n          decryptedId: y\n        });\n      }\n      const m = v[s].req;\n      if (m.attestation = w, r && (m.ttl = r), n && (m.id = n), this.client.core.history.set(t, p), l) {\n        const y = he(h, t, d);\n        await global.Linking.openURL(y, this.client.name);\n      } else {\n        const y = v[s].req;\n        r && (y.ttl = r), n && (y.id = n), c ? (y.internal = D(I({}, y.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(t, d, y)) : this.client.core.relayer.publish(t, d, y).catch(_ => this.client.logger.error(_));\n      }\n      return p.id;\n    }, this.sendResult = async e => {\n      const {\n          id: t,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: n,\n          appLink: a\n        } = e,\n        c = rs(t, i);\n      let h;\n      const p = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const l = p ? ie : de;\n        h = await this.client.core.crypto.encode(s, c, D(I({}, n || {}), {\n          encoding: l\n        }));\n      } catch (l) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), l;\n      }\n      let d;\n      try {\n        d = await this.client.core.history.get(s, t);\n      } catch (l) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), l;\n      }\n      if (p) {\n        const l = he(a, s, h);\n        await global.Linking.openURL(l, this.client.name);\n      } else {\n        const l = v[d.request.method].res;\n        r ? (l.internal = D(I({}, l.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(s, h, l)) : this.client.core.relayer.publish(s, h, l).catch(w => this.client.logger.error(w));\n      }\n      await this.client.core.history.resolve(c);\n    }, this.sendError = async e => {\n      const {\n          id: t,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: n,\n          appLink: a\n        } = e,\n        c = ns(t, i);\n      let h;\n      const p = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const l = p ? ie : de;\n        h = await this.client.core.crypto.encode(s, c, D(I({}, r || {}), {\n          encoding: l\n        }));\n      } catch (l) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), l;\n      }\n      let d;\n      try {\n        d = await this.client.core.history.get(s, t);\n      } catch (l) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), l;\n      }\n      if (p) {\n        const l = he(a, s, h);\n        await global.Linking.openURL(l, this.client.name);\n      } else {\n        const l = n || v[d.request.method].res;\n        this.client.core.relayer.publish(s, h, l);\n      }\n      await this.client.core.history.resolve(c);\n    }, this.cleanup = async () => {\n      const e = [],\n        t = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        B(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && e.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        B(s.expiryTimestamp) && t.push(s.id);\n      }), await Promise.all([...e.map(s => this.deleteSession({\n        topic: s\n      })), ...t.map(s => this.deleteProposal(s))]);\n    }, this.onRelayEventRequest = async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === L.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = L.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          await this.processRequest(e);\n        } catch (t) {\n          this.client.logger.warn(t);\n        }\n      }\n      this.requestQueue.state = L.idle;\n    }, this.processRequest = async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          transportType: r,\n          encryptedId: n\n        } = e,\n        a = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: t,\n        requestMethod: a\n      })) switch (a) {\n        case \"wc_sessionPropose\":\n          return await this.onSessionProposeRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n\n          });\n        case \"wc_sessionSettle\":\n          return await this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return await this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return await this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return await this.onSessionPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return await this.onSessionDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return await this.onSessionRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n,\n            transportType: r\n          });\n        case \"wc_sessionEvent\":\n          return await this.onSessionEventRequest(t, s);\n        case \"wc_sessionAuthenticate\":\n          return await this.onSessionAuthenticateRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n,\n            transportType: r\n          });\n        default:\n          return this.client.logger.info(`Unsupported request method ${a}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: t,\n          payload: s,\n          transportType: i\n        } = e,\n        r = (await this.client.core.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s, i);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: t\n        } = e,\n        {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }, this.shouldIgnorePairingRequest = e => {\n      const {\n          topic: t,\n          requestMethod: s\n        } = e,\n        i = this.expectedPairingMethodMap.get(t);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }, this.onSessionProposeRequest = async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          encryptedId: r\n        } = e,\n        {\n          params: n,\n          id: a\n        } = s;\n      try {\n        const c = this.client.core.eventClient.getEvent({\n          topic: t\n        });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), c?.setError(St.proposal_listener_not_found)), this.isValidConnect(I({}, s.params));\n        const h = n.expiryTimestamp || b(v.wc_sessionPropose.req.ttl),\n          p = I({\n            id: a,\n            pairingTopic: t,\n            expiryTimestamp: h\n          }, n);\n        await this.setProposal(a, p);\n        const d = await this.getVerifyContext({\n          attestationId: i,\n          hash: J(JSON.stringify(s)),\n          encryptedId: r,\n          metadata: p.proposer.metadata\n        });\n        c?.addTrace(It.emit_session_proposal), this.client.events.emit(\"session_proposal\", {\n          id: a,\n          params: p,\n          verifyContext: d\n        });\n      } catch (c) {\n        await this.sendError({\n          id: a,\n          topic: t,\n          error: c,\n          rpcOpts: v.wc_sessionPropose.autoReject\n        }), this.client.logger.error(c);\n      }\n    }, this.onSessionProposeResponse = async (e, t, s) => {\n      const {\n        id: i\n      } = t;\n      if (K(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const n = this.client.proposal.get(i);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const a = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const c = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: c\n        });\n        const h = await this.client.core.crypto.generateSharedKey(a, c);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: h\n        });\n        const p = await this.client.core.relayer.subscribe(h, {\n          transportType: s\n        });\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: p\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else if (U(t)) {\n        await this.client.proposal.delete(i, P(\"USER_DISCONNECTED\"));\n        const r = g(\"session_connect\");\n        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);\n        this.events.emit(g(\"session_connect\"), {\n          error: t.error\n        });\n      }\n    }, this.onSessionSettleRequest = async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: n,\n            expiry: a,\n            namespaces: c,\n            sessionProperties: h,\n            sessionConfig: p\n          } = t.params,\n          d = D(I(I({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: c,\n            acknowledged: !0,\n            pairingTopic: \"\",\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            controller: n.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: n.publicKey,\n              metadata: n.metadata\n            }\n          }, h && {\n            sessionProperties: h\n          }), p && {\n            sessionConfig: p\n          }), {\n            transportType: f.relay\n          }),\n          l = g(\"session_connect\");\n        if (this.events.listenerCount(l) === 0) throw new Error(`emitting ${l} without any listeners 997`);\n        this.events.emit(g(\"session_connect\"), {\n          session: d\n        }), await this.sendResult({\n          id: t.id,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionSettleResponse = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      K(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(g(\"session_approve\", s), {})) : U(t) && (await this.client.session.delete(e, P(\"USER_DISCONNECTED\")), this.events.emit(g(\"session_approve\", s), {\n        error: t.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, t) => {\n      const {\n        params: s,\n        id: i\n      } = t;\n      try {\n        const r = `${e}_session_update`,\n          n = re.get(r);\n        if (n && this.isRequestOutOfSync(n, i)) {\n          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: e,\n            error: P(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(I({\n          topic: e\n        }, s));\n        try {\n          re.set(r, i), await this.client.session.update(e, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: e,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw re.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.isRequestOutOfSync = (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3), this.onSessionUpdateResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_update\", s), {}) : U(t) && this.events.emit(g(\"session_update\", s), {\n        error: t.error\n      });\n    }, this.onSessionExtendRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, b(H)), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_extend\", s), {}) : U(t) && this.events.emit(g(\"session_extend\", s), {\n        error: t.error\n      });\n    }, this.onSessionPingRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_ping\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      setTimeout(() => {\n        K(t) ? this.events.emit(g(\"session_ping\", s), {}) : U(t) && this.events.emit(g(\"session_ping\", s), {\n          error: t.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Ge.publish, async () => {\n            i(await this.deleteSession({\n              topic: e,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: e,\n          error: P(\"USER_DISCONNECTED\")\n        })]).catch(i => this.client.logger.error(i));\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async e => {\n      var t, s, i;\n      const {\n          topic: r,\n          payload: n,\n          attestation: a,\n          encryptedId: c,\n          transportType: h\n        } = e,\n        {\n          id: p,\n          params: d\n        } = n;\n      try {\n        await this.isValidRequest(I({\n          topic: r\n        }, d));\n        const l = this.client.session.get(r),\n          w = await this.getVerifyContext({\n            attestationId: a,\n            hash: J(JSON.stringify(ge(\"wc_sessionRequest\", d, p))),\n            encryptedId: c,\n            metadata: l.peer.metadata,\n            transportType: h\n          }),\n          m = {\n            id: p,\n            topic: r,\n            params: d,\n            verifyContext: w\n          };\n        await this.setPendingSessionRequest(m), h === f.link_mode && (t = l.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = l.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());\n      } catch (l) {\n        await this.sendError({\n          id: p,\n          topic: r,\n          error: l\n        }), this.client.logger.error(l);\n      }\n    }, this.onSessionRequestResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_request\", s), {\n        result: t.result\n      }) : U(t) && this.events.emit(g(\"session_request\", s), {\n        error: t.error\n      });\n    }, this.onSessionEventRequest = async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        const r = `${e}_session_event_${i.event.name}`,\n          n = re.get(r);\n        if (n && this.isRequestOutOfSync(n, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(I({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: i\n        }), re.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionAuthenticateResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: e,\n        payload: t\n      }), K(t) ? this.events.emit(g(\"session_request\", s), {\n        result: t.result\n      }) : U(t) && this.events.emit(g(\"session_request\", s), {\n        error: t.error\n      });\n    }, this.onSessionAuthenticateRequest = async e => {\n      var t;\n      const {\n        topic: s,\n        payload: i,\n        attestation: r,\n        encryptedId: n,\n        transportType: a\n      } = e;\n      try {\n        const {\n            requester: c,\n            authPayload: h,\n            expiryTimestamp: p\n          } = i.params,\n          d = await this.getVerifyContext({\n            attestationId: r,\n            hash: J(JSON.stringify(i)),\n            encryptedId: n,\n            metadata: c.metadata,\n            transportType: a\n          }),\n          l = {\n            requester: c,\n            pairingTopic: s,\n            id: i.id,\n            authPayload: h,\n            verifyContext: d,\n            expiryTimestamp: p\n          };\n        await this.setAuthRequest(i.id, {\n          request: l,\n          pairingTopic: s,\n          transportType: a\n        }), a === f.link_mode && (t = c.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", {\n          topic: s,\n          params: i.params,\n          id: i.id,\n          verifyContext: d\n        });\n      } catch (c) {\n        this.client.logger.error(c);\n        const h = i.params.requester.publicKey,\n          p = await this.client.core.crypto.generateKeyPair(),\n          d = this.getAppLinkIfEnabled(i.params.requester.metadata, a),\n          l = {\n            type: be,\n            receiverPublicKey: h,\n            senderPublicKey: p\n          };\n        await this.sendError({\n          id: i.id,\n          topic: s,\n          error: c,\n          encodeOpts: l,\n          rpcOpts: v.wc_sessionAuthenticate.autoReject,\n          appLink: d\n        });\n      }\n    }, this.addSessionRequestToSessionRequestQueue = e => {\n      this.sessionRequestQueue.queue.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = L.idle, this.processSessionRequestQueue();\n      }, Te(this.requestQueueDelay));\n    }, this.cleanupPendingSentRequestsForTopic = ({\n      topic: e,\n      error: t\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === e && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          n = g(\"session_request\", r);\n        if (this.events.listenerCount(n) === 0) throw new Error(`emitting ${n} without any listeners`);\n        this.events.emit(g(\"session_request\", i.request.id), {\n          error: t\n        });\n      });\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === L.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = L.active, this.emitSessionRequest(e);\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }, this.emitSessionRequest = e => {\n      this.client.events.emit(\"session_request\", e);\n    }, this.onPairingCreated = e => {\n      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;\n      const t = this.client.proposal.getAll().find(s => s.pairingTopic === e.topic);\n      t && this.onSessionProposeRequest({\n        topic: e.topic,\n        payload: ge(\"wc_sessionPropose\", {\n          requiredNamespaces: t.requiredNamespaces,\n          optionalNamespaces: t.optionalNamespaces,\n          relays: t.relays,\n          proposer: t.proposer,\n          sessionProperties: t.sessionProperties\n        }, t.id)\n      });\n    }, this.isValidConnect = async e => {\n      if (!x(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        relays: n\n      } = e;\n      if (ne(t) || (await this.isValidPairingTopic(t)), !Kt(n, !0)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `connect() relays: ${n}`);\n        throw new Error(a);\n      }\n      !ne(s) && Ze(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !ne(i) && Ze(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), ne(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.validateNamespaces = (e, t) => {\n      const s = Ut(e, \"connect()\", t);\n      if (s) throw new Error(s.message);\n    }, this.isValidApprove = async e => {\n      if (!x(e)) throw new Error(u(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);\n      const n = this.client.proposal.get(t),\n        a = Ae(s, \"approve()\");\n      if (a) throw new Error(a.message);\n      const c = et(n.requiredNamespaces, s, \"approve()\");\n      if (c) throw new Error(c.message);\n      if (!$(i, !0)) {\n        const {\n          message: h\n        } = u(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      ne(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!x(e)) {\n        const {\n          message: i\n        } = u(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Gt(s)) {\n        const {\n          message: i\n        } = u(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!x(e)) {\n        const {\n          message: c\n        } = u(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(c);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!jt(t)) {\n        const {\n          message: c\n        } = u(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(c);\n      }\n      const n = Ft(s, \"onSessionSettleRequest()\");\n      if (n) throw new Error(n.message);\n      const a = Ae(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (B(r)) {\n        const {\n          message: c\n        } = u(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(c);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!x(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const i = this.client.session.get(t),\n        r = Ae(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const n = et(i.requiredNamespaces, s, \"update()\");\n      if (n) throw new Error(n.message);\n    }, this.isValidExtend = async e => {\n      if (!x(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n    }, this.isValidRequest = async e => {\n      if (!x(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const {\n        namespaces: n\n      } = this.client.session.get(t);\n      if (!tt(n, i)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Qt(s)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!zt(n, i, s.method)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !Ht(r, me)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      var t;\n      if (!x(e)) {\n        const {\n          message: r\n        } = u(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = e;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;\n      }\n      if (!Yt(i)) {\n        const {\n          message: r\n        } = u(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async e => {\n      if (!x(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }, this.isValidEmit = async e => {\n      if (!x(e)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(n);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: r\n      } = this.client.session.get(t);\n      if (!tt(r, i)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(n);\n      }\n      if (!Xt(s)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(n);\n      }\n      if (!Jt(r, i, s.name)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(n);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!x(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }, this.isValidAuthenticate = e => {\n      const {\n        chains: t,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = e;\n      if (!Array.isArray(t) || t.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!$(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!$(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!$(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(t.map(a => Pe(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: n\n      } = Pe(t[0]);\n      if (n !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }, this.getVerifyContext = async e => {\n      const {\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          metadata: r,\n          transportType: n\n        } = e,\n        a = {\n          verified: {\n            verifyUrl: r.verifyUrl || ft,\n            validation: \"UNKNOWN\",\n            origin: r.url || \"\"\n          }\n        };\n      try {\n        if (n === f.link_mode) {\n          const h = this.getAppLinkIfEnabled(r, n);\n          return a.verified.validation = h && new URL(h).origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\", a;\n        }\n        const c = await this.client.core.verify.resolve({\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          verifyUrl: r.verifyUrl\n        });\n        c && (a.verified.origin = c.origin, a.verified.isScam = c.isScam, a.verified.validation = c.origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (c) {\n        this.client.logger.warn(c);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;\n    }, this.validateSessionProps = (e, t) => {\n      Object.values(e).forEach(s => {\n        if (!$(s, !1)) {\n          const {\n            message: i\n          } = u(\"MISSING_OR_INVALID\", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);\n          throw new Error(i);\n        }\n      });\n    }, this.getPendingAuthRequest = e => {\n      const t = this.client.auth.requests.get(e);\n      return typeof t == \"object\" ? t : void 0;\n    }, this.addToRecentlyDeleted = (e, t) => {\n      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }, this.checkRecentlyDeleted = e => {\n      const t = this.recentlyDeletedMap.get(e);\n      if (t) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `Record was recently deleted - ${t}: ${e}`);\n        throw new Error(s);\n      }\n    }, this.isLinkModeEnabled = (e, t) => {\n      var s, i, r, n, a, c, h, p, d;\n      return !e || t !== f.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((n = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : n.universal) !== void 0 && ((c = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : c.universal) !== \"\" && ((h = e?.redirect) == null ? void 0 : h.universal) !== void 0 && ((p = e?.redirect) == null ? void 0 : p.universal) !== \"\" && ((d = e?.redirect) == null ? void 0 : d.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }, this.getAppLinkIfEnabled = (e, t) => {\n      var s;\n      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;\n    }, this.handleLinkModeMessage = ({\n      url: e\n    }) => {\n      if (!e || !e.includes(\"wc_ev\") || !e.includes(\"topic\")) return;\n      const t = st(e, \"topic\") || \"\",\n        s = decodeURIComponent(st(e, \"wc_ev\") || \"\"),\n        i = this.client.session.keys.includes(t);\n      i && this.client.session.update(t, {\n        transportType: f.link_mode\n      }), this.client.core.dispatchEnvelope({\n        topic: t,\n        message: s,\n        sessionExists: i\n      });\n    }, this.registerLinkModeListeners = async () => {\n      var e;\n      if (Bt() || Wt() && (e = this.client.metadata.redirect) != null && e.linkMode) {\n        const t = global == null ? void 0 : global.Linking;\n        if (typeof t < \"u\") {\n          t.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const s = await t.getInitialURL();\n          s && setTimeout(() => {\n            this.handleLinkModeMessage({\n              url: s\n            });\n          }, 50);\n        }\n      }\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: o\n      } = u(\"NOT_INITIALIZED\", this.name);\n      throw new Error(o);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Ge.message, o => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o) : this.onRelayMessage(o);\n    });\n  }\n  async onRelayMessage(o) {\n    const {\n        topic: e,\n        message: t,\n        attestation: s,\n        transportType: i\n      } = o,\n      {\n        publicKey: r\n      } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : {\n        responseTopic: void 0,\n        publicKey: void 0\n      },\n      n = await this.client.core.crypto.decode(e, t, {\n        receiverPublicKey: r,\n        encoding: i === f.link_mode ? ie : de\n      });\n    try {\n      os(n) ? (this.client.core.history.set(e, n), this.onRelayEventRequest({\n        topic: e,\n        payload: n,\n        attestation: s,\n        transportType: i,\n        encryptedId: J(t)\n      })) : as(n) ? (await this.client.core.history.resolve(n), await this.onRelayEventResponse({\n        topic: e,\n        payload: n,\n        transportType: i\n      }), this.client.core.history.delete(e, n.id)) : this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: n,\n        transportType: i\n      });\n    } catch (a) {\n      this.client.logger.error(a);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(vt.expired, async o => {\n      const {\n        topic: e,\n        id: t\n      } = Zt(o.target);\n      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, u(\"EXPIRED\"), !0);\n      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, u(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession({\n        topic: e,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t, !0), this.client.events.emit(\"proposal_expire\", {\n        id: t\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(je.create, o => this.onPairingCreated(o)), this.client.core.pairing.events.on(je.delete, o => {\n      this.addToRecentlyDeleted(o.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(o) {\n    if (!$(o, !1)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.core.pairing.pairings.get(o).expiry)) {\n      const {\n        message: e\n      } = u(\"EXPIRED\", `pairing topic: ${o}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(o) {\n    if (!$(o, !1)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n    if (this.checkRecentlyDeleted(o), !this.client.session.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.session.get(o).expiry)) {\n      await this.deleteSession({\n        topic: o\n      });\n      const {\n        message: e\n      } = u(\"EXPIRED\", `session topic: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.crypto.keychain.has(o)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${o}`);\n      throw await this.deleteSession({\n        topic: o\n      }), new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(o) {\n    if (this.checkRecentlyDeleted(o), this.client.session.keys.includes(o)) await this.isValidSessionTopic(o);else if (this.client.core.pairing.pairings.keys.includes(o)) this.isValidPairingTopic(o);else if ($(o, !1)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${o}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(o) {\n    if (!es(o)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `proposal id should be a number: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.proposal.get(o).expiryTimestamp)) {\n      await this.deleteProposal(o);\n      const {\n        message: e\n      } = u(\"EXPIRED\", `proposal id: ${o}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ss extends Y {\n  constructor(o, e) {\n    super(o, e, it, ye), this.core = o, this.logger = e;\n  }\n}\nclass wt extends Y {\n  constructor(o, e) {\n    super(o, e, nt, ye), this.core = o, this.logger = e;\n  }\n}\nclass Is extends Y {\n  constructor(o, e) {\n    super(o, e, at, ye, t => t.id), this.core = o, this.logger = e;\n  }\n}\nclass fs extends Y {\n  constructor(o, e) {\n    super(o, e, ht, oe, () => ae), this.core = o, this.logger = e;\n  }\n}\nclass vs extends Y {\n  constructor(o, e) {\n    super(o, e, dt, oe), this.core = o, this.logger = e;\n  }\n}\nclass qs extends Y {\n  constructor(o, e) {\n    super(o, e, ut, oe, t => t.id), this.core = o, this.logger = e;\n  }\n}\nclass Ts {\n  constructor(o, e) {\n    this.core = o, this.logger = e, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nclass _e extends bt {\n  constructor(o) {\n    super(o), this.protocol = Ce, this.version = xe, this.name = we.name, this.events = new is(), this.on = (t, s) => this.events.on(t, s), this.once = (t, s) => this.events.once(t, s), this.off = (t, s) => this.events.off(t, s), this.removeListener = (t, s) => this.events.removeListener(t, s), this.removeAllListeners = t => this.events.removeAllListeners(t), this.connect = async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.pair = async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approve = async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.reject = async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.update = async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.extend = async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.request = async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.respond = async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.ping = async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.emit = async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.disconnect = async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.find = t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.authenticate = async (t, s) => {\n      try {\n        return await this.engine.authenticate(t, s);\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }, this.formatAuthMessage = t => {\n      try {\n        return this.engine.formatAuthMessage(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approveSessionAuthenticate = async t => {\n      try {\n        return await this.engine.approveSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.rejectSessionAuthenticate = async t => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = o?.name || we.name, this.metadata = o?.metadata || ts(), this.signConfig = o?.signConfig;\n    const e = typeof o?.logger < \"u\" && typeof o?.logger != \"string\" ? o.logger : Tt(Nt({\n      level: o?.logger || we.logger\n    }));\n    this.core = o?.core || new qt(o), this.logger = Pt(e, this.name), this.session = new wt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);\n  }\n  static async init(o) {\n    const e = new _e(o);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Ot(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, Te(ze));\n    } catch (o) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(o.message), o;\n    }\n  }\n}\nconst Ns = wt,\n  Ps = _e;\nexport { pt as AUTH_CONTEXT, ht as AUTH_KEYS_CONTEXT, dt as AUTH_PAIRING_TOPIC_CONTEXT, lt as AUTH_PROTOCOL, ae as AUTH_PUBLIC_KEY_NAME, ut as AUTH_REQUEST_CONTEXT, oe as AUTH_STORAGE_PREFIX, gs as AUTH_VERSION, ot as ENGINE_CONTEXT, L as ENGINE_QUEUE_STATES, v as ENGINE_RPC_OPTS, hs as HISTORY_CONTEXT, ps as HISTORY_EVENTS, ds as HISTORY_STORAGE_VERSION, ct as METHODS_TO_VERIFY, it as PROPOSAL_CONTEXT, us as PROPOSAL_EXPIRY, rt as PROPOSAL_EXPIRY_MESSAGE, at as REQUEST_CONTEXT, nt as SESSION_CONTEXT, H as SESSION_EXPIRY, me as SESSION_REQUEST_EXPIRY_BOUNDARIES, Le as SIGN_CLIENT_CONTEXT, we as SIGN_CLIENT_DEFAULT, cs as SIGN_CLIENT_EVENTS, Ce as SIGN_CLIENT_PROTOCOL, ls as SIGN_CLIENT_STORAGE_OPTIONS, ye as SIGN_CLIENT_STORAGE_PREFIX, xe as SIGN_CLIENT_VERSION, Ns as SessionStore, Ps as SignClient, De as WALLETCONNECT_DEEPLINK_CHOICE, _e as default };","map":{"version":3,"names":[],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/client.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/history.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/proposal.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/session.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/engine.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/pendingRequest.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/verify.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/constants/auth.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/engine.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/proposal.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/session.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/pendingRequest.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/authKey.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/authPairingTopic.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/authRequest.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/controllers/authStore.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/client.ts","/Users/papa/Desktop/trenchboard/trenchboard.io/node_modules/@walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.org\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_authenticate: \"session_authenticate\",\n  session_request_expire: \"session_request_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\n  \"wc_sessionPropose\",\n  \"wc_sessionRequest\",\n  \"wc_authRequest\",\n  \"wc_sessionAuthenticate\",\n];\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","/* eslint-disable no-console */\nimport {\n  EVENT_CLIENT_AUTHENTICATE_ERRORS,\n  EVENT_CLIENT_AUTHENTICATE_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_SESSION_ERRORS,\n  EVENT_CLIENT_SESSION_TRACES,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  TYPE_2,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n  getLinkModeURL,\n  BASE64,\n  BASE64URL,\n  getSearchParamFromURL,\n  isReactNative,\n  isTestRun,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n  private relayMessageCache: RelayerTypes.MessageEvent[] = [];\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      await this.registerLinkModeListeners();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        this.client.logger.warn(\n          \"connect() with existing pairing topic is deprecated and will be removed in the next major release.\",\n        );\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            pairingTopic: proposal.pairingTopic,\n            requiredNamespaces: proposal.requiredNamespaces,\n            optionalNamespaces: proposal.optionalNamespaces,\n            transportType: TRANSPORT_TYPES.relay,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          this.cleanupDuplicatePairings(completeSession);\n          resolve(completeSession);\n        }\n      },\n    );\n    const id = await this.sendRequest({\n      topic,\n      method: \"wc_sessionPropose\",\n      params: proposal,\n      throwOnFailedPublish: true,\n    });\n    await this.setProposal(id, { id, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    const configEvent = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],\n      },\n    });\n    try {\n      this.isInitialized();\n      await this.confirmOnlineStateOrThrow();\n    } catch (error) {\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);\n      throw error;\n    }\n    try {\n      await this.isValidProposalId(params?.id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);\n      throw error;\n    }\n\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      configEvent.setError(\n        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,\n      );\n      throw error;\n    }\n\n    const { id, relayProtocol, namespaces, sessionProperties, sessionConfig } = params;\n\n    const proposal = this.client.proposal.get(id);\n\n    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    let event = this.client.core.eventClient?.getEvent({\n      topic: pairingTopic,\n    }) as EventClientTypes.Event;\n    if (!event) {\n      event = this.client.core.eventClient?.createEvent({\n        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n        properties: {\n          topic: pairingTopic,\n          trace: [\n            EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,\n          ],\n        },\n      });\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    const transportType = TRANSPORT_TYPES.relay;\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);\n    try {\n      await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n      transportType: TRANSPORT_TYPES.relay,\n    };\n    await this.client.session.set(sessionTopic, session);\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);\n\n    try {\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_settle);\n      await this.sendRequest({\n        topic: sessionTopic,\n        method: \"wc_sessionSettle\",\n        params: sessionSettle,\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success);\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_approve);\n      await this.sendResult<\"wc_sessionPropose\">({\n        id,\n        topic: pairingTopic,\n        result: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n\n    if (session?.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (appLink) {\n      await this.sendRequest({\n        clientRpcId,\n        relayRpcId,\n        topic,\n        method: \"wc_sessionRequest\",\n        params: {\n          request: {\n            ...request,\n            expiryTimestamp: calcExpiry(expiry),\n          },\n          chainId,\n        },\n        expiry,\n        throwOnFailedPublish: true,\n        appLink,\n      }).catch((error) => reject(error));\n\n      this.client.events.emit(\"session_request_sent\", {\n        topic,\n        request,\n        chainId,\n        id: clientRpcId,\n      });\n      const result = await done();\n      return result;\n    }\n\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: {\n              ...request,\n              expiryTimestamp: calcExpiry(expiry),\n            },\n            chainId,\n          },\n          expiry,\n          throwOnFailedPublish: true,\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = (await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          )) as string;\n          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    const session = this.client.session.get(topic);\n\n    if (session.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({\n        id,\n        topic,\n        result: response.result,\n        throwOnFailedPublish: true,\n        appLink,\n      });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError({ id, topic, error: response.error, appLink });\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.client.logger.warn(\n        \"ping() on pairing topic is deprecated and will be removed in the next major release.\",\n      );\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const clientRpcId = payloadId();\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n      clientRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params, walletUniversalLink) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const isLinkMode =\n      walletUniversalLink &&\n      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&\n      this.client.metadata.redirect?.linkMode;\n\n    const transportType: RelayerTypes.TransportType = isLinkMode\n      ? TRANSPORT_TYPES.link_mode\n      : TRANSPORT_TYPES.relay;\n\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n      transportType,\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic, { transportType });\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request: AuthTypes.SessionAuthenticateRequestParams = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(engineEvent(\"session_request\", id), onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        session.self.publicKey = publicKey;\n        await this.client.session.set(session.topic, session);\n        await this.setExpiry(session.topic, session.expiry);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: session.peer.metadata,\n          });\n        }\n        const sessionObject = this.client.session.get(session.topic);\n        await this.deleteProposal(fallbackId);\n        resolve({\n          session: sessionObject,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(id, { message: \"fulfilled\", code: 0 });\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(fallbackId);\n      // cleanup listener for fallback response\n      this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n          transportType,\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n        await this.client.session.set(sessionTopic, session);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: responder.metadata,\n          });\n        }\n\n        session = this.client.session.get(sessionTopic);\n      }\n\n      if (\n        this.client.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.universal &&\n        walletUniversalLink\n      ) {\n        // save wallet link in array of apps that support linkMode\n        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);\n\n        this.client.session.update(sessionTopic, {\n          transportType: TRANSPORT_TYPES.link_mode,\n        });\n      }\n\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // set the ids for both requests\n    const id = payloadId();\n    const fallbackId = payloadId();\n    // subscribe to response events\n    this.events.once<\"session_connect\">(engineEvent(\"session_connect\"), onSessionConnect);\n    this.events.once(engineEvent(\"session_request\", id), onAuthenticate);\n\n    let linkModeURL;\n    try {\n      if (isLinkMode) {\n        const payload = formatJsonRpcRequest(\"wc_sessionAuthenticate\", request, id);\n        this.client.core.history.set(pairingTopic, payload);\n        const message = await this.client.core.crypto.encode(\"\", payload, {\n          type: TYPE_2,\n          encoding: BASE64URL,\n        });\n        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);\n      } else {\n        // send both (main & fallback) requests\n        await Promise.all([\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionAuthenticate\",\n            params: request,\n            expiry: params.expiry,\n            throwOnFailedPublish: true,\n            clientRpcId: id,\n          }),\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionPropose\",\n            params: proposal,\n            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n            throwOnFailedPublish: true,\n            clientRpcId: fallbackId,\n          }),\n        ]);\n      }\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n      this.events.off(engineEvent(\"session_request\", id), onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(fallbackId, { id: fallbackId, ...proposal });\n    await this.setAuthRequest(id, {\n      request: {\n        ...request,\n        verifyContext: {} as any,\n      },\n      pairingTopic,\n      transportType,\n    });\n\n    return {\n      uri: linkModeURL ?? connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: id.toString(),\n        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],\n      },\n    });\n\n    try {\n      this.isInitialized();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);\n      throw error;\n    }\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,\n      );\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);\n\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);\n\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: pendingRequest.pairingTopic,\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n        transportType,\n      };\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);\n\n      try {\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n      } catch (error) {\n        event.setError(\n          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,\n        );\n        throw error;\n      }\n\n      event.addTrace(\n        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,\n      );\n\n      await this.client.session.set(sessionTopic, session);\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingRequest.pairingTopic,\n        metadata: pendingRequest.requester.metadata,\n      });\n    }\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);\n\n    try {\n      await this.sendResult<\"wc_sessionAuthenticate\">({\n        topic: responseTopic,\n        id,\n        result: {\n          cacaos: auths,\n          responder: {\n            publicKey: senderPublicKey,\n            metadata: this.client.metadata,\n          },\n        },\n        encodeOpts,\n        throwOnFailedPublish: true,\n        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),\n      });\n    } catch (error) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,\n      );\n      throw error;\n    }\n\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n      appLink: this.getAppLinkIfEnabled(\n        pendingRequest.requester.metadata,\n        pendingRequest.transportType,\n      ),\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  public processRelayMessageCache: IEngine[\"processRelayMessageCache\"] = () => {\n    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app\n    setTimeout(async () => {\n      if (this.relayMessageCache.length === 0) return;\n      while (this.relayMessageCache.length > 0) {\n        try {\n          const message = this.relayMessageCache.shift();\n          if (message) {\n            await this.onRelayMessage(message);\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      }\n    }, 50);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    if (expirerHasDeleted) {\n      try {\n        const proposal = this.client.proposal.get(id);\n        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);\n      } catch (error) {}\n    }\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n      transportType,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const {\n      topic,\n      method,\n      params,\n      expiry,\n      relayRpcId,\n      clientRpcId,\n      throwOnFailedPublish,\n      appLink,\n    } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n\n    let message: string;\n    const isLinkMode = !!appLink;\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, { encoding });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n\n    let attestation: string | undefined;\n    if (METHODS_TO_VERIFY.includes(method)) {\n      const decryptedId = hashMessage(JSON.stringify(payload));\n      const id = hashMessage(message);\n      attestation = await this.client.core.verify.register({ id, decryptedId });\n    }\n    const opts = ENGINE_RPC_OPTS[method].req;\n    opts.attestation = attestation;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const opts = ENGINE_RPC_OPTS[method].req;\n      if (expiry) opts.ttl = expiry;\n      if (relayRpcId) opts.id = relayRpcId;\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const opts = ENGINE_RPC_OPTS[record.request.method].res;\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const opts = rpcOpts || ENGINE_RPC_OPTS[record.request.method].res;\n      // await is intentionally omitted to speed up performance\n      this.client.core.relayer.publish(topic, message, opts);\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {\n      // capture any messages that arrive before the client is initialized so we can process them after initialization is complete\n      if (!this.initialized || this.relayMessageCache.length > 0) {\n        this.relayMessageCache.push(event);\n      } else {\n        this.onRelayMessage(event);\n      }\n    });\n  }\n\n  private async onRelayMessage(event: RelayerTypes.MessageEvent) {\n    const { topic, message, attestation, transportType } = event;\n\n    // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n      : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n    const payload = await this.client.core.crypto.decode(topic, message, {\n      receiverPublicKey: publicKey,\n      encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,\n    });\n    try {\n      if (isJsonRpcRequest(payload)) {\n        this.client.core.history.set(topic, payload);\n        this.onRelayEventRequest({\n          topic,\n          payload,\n          attestation,\n          transportType,\n          encryptedId: hashMessage(message),\n        });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.client.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload, transportType });\n        this.client.core.history.delete(topic, payload.id);\n      } else {\n        this.onRelayEventUnknownPayload({ topic, payload, transportType });\n      }\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        await this.processRequest(request);\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload, attestation, transportType, encryptedId } = event;\n\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });\n      case \"wc_sessionSettle\":\n        return await this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return await this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return await this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return await this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return await this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return await this.onSessionRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      case \"wc_sessionEvent\":\n        return await this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return await this.onSessionAuthenticateRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload, transportType } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload, transportType);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId } = args;\n    const { params, id } = payload;\n    try {\n      const event = this.client.core.eventClient.getEvent({ topic });\n\n      if (this.client.events.listenerCount(\"session_proposal\") === 0) {\n        console.warn(\"No listener for session_proposal event\");\n        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);\n      }\n\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };\n      await this.setProposal(id, proposal);\n\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: proposal.proposer.metadata,\n      });\n\n      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);\n\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n    transportType,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n      });\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      const target = engineEvent(\"session_connect\");\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const { relay, controller, expiry, namespaces, sessionProperties, sessionConfig } =\n        payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: \"\", // pairingTopic will be set in the `session_connect` handler\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(sessionConfig && { sessionConfig }),\n        transportType: TRANSPORT_TYPES.relay,\n      };\n      const target = engineEvent(\"session_connect\");\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 997`);\n      }\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.warn(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]).catch((err) => this.client.logger.error(err));\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id))),\n        encryptedId,\n        metadata: session.peer.metadata,\n        transportType,\n      });\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n\n      if (\n        transportType === TRANSPORT_TYPES.link_mode &&\n        session.peer.metadata.redirect?.universal\n      ) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);\n      }\n\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    args,\n  ) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: requester.metadata,\n        transportType,\n      });\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, {\n        request: pendingRequest,\n        pairingTopic: topic,\n        transportType,\n      });\n\n      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);\n      }\n\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n        verifyContext,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n        appLink,\n      });\n    }\n  };\n\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest({\n      topic: pairing.topic,\n      payload: formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n        },\n        proposal.id,\n      ),\n    });\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    metadata: CoreTypes.Metadata;\n    transportType?: RelayerTypes.TransportType;\n  }) => {\n    const { attestationId, hash, encryptedId, metadata, transportType } = params;\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      if (transportType === TRANSPORT_TYPES.link_mode) {\n        const applink = this.getAppLinkIfEnabled(metadata, transportType);\n        context.verified.validation =\n          applink && new URL(applink).origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n        return context;\n      }\n      const result = await this.client.core.verify.resolve({\n        attestationId,\n        hash,\n        encryptedId,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.warn(e);\n    }\n\n    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isLinkModeEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): boolean => {\n    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;\n\n    return (\n      this.client.metadata?.redirect?.linkMode === true &&\n      this.client.metadata?.redirect?.universal !== undefined &&\n      this.client.metadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.universal !== undefined &&\n      peerMetadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.linkMode === true &&\n      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&\n      typeof (global as any)?.Linking !== \"undefined\"\n    );\n  };\n\n  private getAppLinkIfEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): string | undefined => {\n    return this.isLinkModeEnabled(peerMetadata, transportType)\n      ? peerMetadata?.redirect?.universal\n      : undefined;\n  };\n\n  private handleLinkModeMessage = ({ url }: { url: string }) => {\n    if (!url || !url.includes(\"wc_ev\") || !url.includes(\"topic\")) return;\n\n    const topic = getSearchParamFromURL(url, \"topic\") || \"\";\n    const message = decodeURIComponent(getSearchParamFromURL(url, \"wc_ev\") || \"\");\n\n    const sessionExists = this.client.session.keys.includes(topic);\n\n    if (sessionExists) {\n      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });\n    }\n\n    this.client.core.dispatchEnvelope({ topic, message, sessionExists });\n  };\n\n  private registerLinkModeListeners = async () => {\n    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {\n      const linking = (global as any)?.Linking;\n      // global.Linking is set by react-native-compat\n      if (typeof linking !== \"undefined\") {\n        // set URL listener\n        linking.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n\n        // check for initial URL -> cold boots\n        const initialUrl = await linking.getInitialURL();\n        if (initialUrl) {\n          // wait to process the message to allow event listeners to be registered by the implementing app\n          setTimeout(() => {\n            this.handleLinkModeMessage({ url: initialUrl });\n          }, 50);\n        }\n      }\n    }\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from \"../constants\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX } from \"../constants\";\n\nexport class AuthPairingTopic extends Store<string, { topic: string; pairingTopic: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { AuthTypes, ICore } from \"@walletconnect/types\";\n\nimport { AUTH_STORAGE_PREFIX, AUTH_REQUEST_CONTEXT } from \"../constants\";\n\nexport class AuthRequest extends Store<number, AuthTypes.PendingRequest> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      AUTH_REQUEST_CONTEXT,\n      AUTH_STORAGE_PREFIX,\n      (val: AuthTypes.PendingRequest) => val.id,\n    );\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic\";\nimport { AuthRequest } from \"./authRequest\";\nimport { AuthKey } from \"./authKey\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n    this.signConfig = opts?.signConfig;\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params, walletUniversalLink) => {\n    try {\n      return await this.engine.authenticate(params, walletUniversalLink);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.auth.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initialization Success`);\n      setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, toMiliseconds(ONE_SECOND));\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}