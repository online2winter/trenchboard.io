{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n\n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'connected'\n          });\n        });\n        console.log('Subscribed to new token events');\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('Raw WebSocket message:', data);\n\n          // Handle subscription confirmation\n          if (data.message && data.message.includes('Successfully subscribed')) {\n            console.log('Subscription confirmed:', data.message);\n            return;\n          }\n\n          // Transform create token events into our expected format\n          if (data.txType === 'create') {\n            const transformedData = {\n              type: 'newToken',\n              data: {\n                name: data.name || 'Unknown',\n                address: data.mint,\n                timestamp: new Date().toISOString(),\n                initialPrice: data.initialBuy / Math.pow(10, 6),\n                // Convert to SOL\n                initialLiquidity: data.solAmount\n              }\n            };\n            console.log('Transformed token data:', transformedData);\n\n            // Notify all subscribers\n            this.subscribers.forEach((callback, id) => {\n              console.log(`Notifying subscriber ${id}`);\n              callback(transformedData);\n            });\n          }\n        } catch (error) {\n          console.error('Error processing WebSocket message:', error);\n          console.error('Raw message:', event.data);\n        }\n      };\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'disconnected'\n          });\n        });\n        this.attemptReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket Error:', error);\n        // Notify all subscribers of connection error\n        this.subscribers.forEach((callback, id) => {\n          callback({\n            type: 'connection',\n            status: 'error',\n            error\n          });\n        });\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to account trades:', accounts);\n    }\n  }\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to token trades:', tokens);\n    }\n  }\n\n  // Method to check connection status\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      subscriberCount: this.subscribers.size\n    };\n  }\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n\n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    } else if (this.isConnected) {\n      // If already connected, notify the new subscriber of current status\n      callback({\n        type: 'connection',\n        status: 'connected'\n      });\n    }\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n\n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","subscribers","Map","isConnected","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","console","log","connect","WebSocket","onopen","payload","method","send","JSON","stringify","forEach","callback","id","type","status","onmessage","event","data","parse","message","includes","txType","transformedData","name","address","mint","timestamp","Date","toISOString","initialPrice","initialBuy","Math","pow","initialLiquidity","solAmount","error","onclose","attemptReconnect","onerror","setTimeout","subscribeToAccountTrades","accounts","Array","isArray","length","keys","subscribeToTokenTrades","tokens","getConnectionStatus","subscriberCount","size","subscribe","set","from","unsubscribe","delete","disconnect","clearTimeout","close","websocketService"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/src/utils/websocket.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.subscribers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    console.log('WebSocketService initialized');\n  }\n\n  connect() {\n    try {\n      console.log('Connecting to pumpportal.fun WebSocket...');\n      this.ws = new WebSocket('wss://pumpportal.fun/api/data');\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket Connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        \n        // Subscribe to new token events by default\n        const payload = {\n          method: \"subscribeNewToken\"\n        };\n        this.ws.send(JSON.stringify(payload));\n\n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'connected' });\n        });\n\n        console.log('Subscribed to new token events');\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('Raw WebSocket message:', data);\n\n          // Handle subscription confirmation\n          if (data.message && data.message.includes('Successfully subscribed')) {\n            console.log('Subscription confirmed:', data.message);\n            return;\n          }\n\n          // Transform create token events into our expected format\n          if (data.txType === 'create') {\n            const transformedData = {\n              type: 'newToken',\n              data: {\n                name: data.name || 'Unknown',\n                address: data.mint,\n                timestamp: new Date().toISOString(),\n                initialPrice: data.initialBuy / Math.pow(10, 6), // Convert to SOL\n                initialLiquidity: data.solAmount\n              }\n            };\n\n            console.log('Transformed token data:', transformedData);\n\n            // Notify all subscribers\n            this.subscribers.forEach((callback, id) => {\n              console.log(`Notifying subscriber ${id}`);\n              callback(transformedData);\n            });\n          }\n        } catch (error) {\n          console.error('Error processing WebSocket message:', error);\n          console.error('Raw message:', event.data);\n        }\n      };\n\n      this.ws.onclose = () => {\n        this.isConnected = false;\n        console.log('WebSocket Disconnected');\n        \n        // Notify all subscribers of connection status\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'disconnected' });\n        });\n        \n        this.attemptReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket Error:', error);\n        // Notify all subscribers of connection error\n        this.subscribers.forEach((callback, id) => {\n          callback({ type: 'connection', status: 'error', error });\n        });\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.attemptReconnect();\n    }\n  }\n\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, 5000 * this.reconnectAttempts); // Exponential backoff\n    }\n  }\n\n  subscribeToAccountTrades(accounts) {\n    if (this.isConnected && Array.isArray(accounts) && accounts.length > 0) {\n      const payload = {\n        method: \"subscribeAccountTrade\",\n        keys: accounts\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to account trades:', accounts);\n    }\n  }\n\n  subscribeToTokenTrades(tokens) {\n    if (this.isConnected && Array.isArray(tokens) && tokens.length > 0) {\n      const payload = {\n        method: \"subscribeTokenTrade\",\n        keys: tokens\n      };\n      this.ws.send(JSON.stringify(payload));\n      console.log('Subscribed to token trades:', tokens);\n    }\n  }\n\n  // Method to check connection status\n  getConnectionStatus() {\n    return {\n      isConnected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      subscriberCount: this.subscribers.size\n    };\n  }\n\n  subscribe(id, callback) {\n    console.log(`New subscriber registered: ${id}`);\n    this.subscribers.set(id, callback);\n    \n    // If this is the first subscriber, establish connection\n    if (this.subscribers.size === 1) {\n      console.log('First subscriber connected, establishing WebSocket connection');\n      this.connect();\n    } else if (this.isConnected) {\n      // If already connected, notify the new subscriber of current status\n      callback({ type: 'connection', status: 'connected' });\n    }\n\n    console.log('Current subscribers:', Array.from(this.subscribers.keys()));\n    return () => this.unsubscribe(id);\n  }\n\n  unsubscribe(id) {\n    console.log(`Unsubscribing: ${id}`);\n    this.subscribers.delete(id);\n    \n    // If there are no more subscribers, close the connection\n    if (this.subscribers.size === 0) {\n      console.log('No more subscribers, closing WebSocket connection');\n      this.disconnect();\n    }\n\n    console.log('Remaining subscribers:', Array.from(this.subscribers.keys()));\n  }\n\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    this.isConnected = false;\n  }\n}\n\n// Create a singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}