{"ast":null,"code":"import { Connection, PublicKey } from '@solana/web3.js';\nconst SOLANA_RPC_URL = 'https://api.mainnet-beta.solana.com';\nconst connection = new Connection(SOLANA_RPC_URL);\n\n// Jupiter API for price data\nconst JUPITER_API_URL = 'https://price.jup.ag/v4/price';\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst fetchWithRetry = async (url, options = {}, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      // Exponential backoff with jitter\n      const backoff = Math.min(1000 * Math.pow(2, i) + Math.random() * 1000, 10000);\n      await delay(backoff);\n    }\n  }\n};\nconst handleRpcError = async fn => {\n  try {\n    return await fn();\n  } catch (error) {\n    console.error('RPC Error:', error);\n    if (error.message.includes('429') || error.message.includes('rate limit')) {\n      throw new Error('Rate limit exceeded. Please try again later.');\n    }\n    throw error;\n  }\n};\nexport const fetchTokenData = async tokenAddress => {\n  try {\n    var _priceData$data$token;\n    const tokenPublicKey = new PublicKey(tokenAddress);\n\n    // Get token supply with error handling\n    const tokenSupply = await handleRpcError(() => connection.getTokenSupply(tokenPublicKey));\n\n    // Get price from Jupiter with retry\n    const priceData = await fetchWithRetry(`${JUPITER_API_URL}?ids=${tokenAddress}`);\n    const price = ((_priceData$data$token = priceData.data[tokenAddress]) === null || _priceData$data$token === void 0 ? void 0 : _priceData$data$token.price) || 0;\n\n    // Get mock data for volume and price change\n    const volume24h = await getToken24hVolume(tokenAddress);\n    const priceChange24h = await getToken24hPriceChange(tokenAddress);\n    return {\n      price,\n      volume24h,\n      supply: tokenSupply.value.uiAmount,\n      priceChange24h\n    };\n  } catch (error) {\n    console.error('Error fetching token data:', error);\n    throw new Error('Failed to fetch token data. Please try again later.');\n  }\n};\nexport const getWalletBalance = async walletAddress => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    const balance = await handleRpcError(() => connection.getBalance(publicKey));\n    return balance / 1e9; // Convert lamports to SOL\n  } catch (error) {\n    console.error('Error fetching wallet balance:', error);\n    throw new Error('Failed to fetch wallet balance. Please try again later.');\n  }\n};\nexport const getTokenAccounts = async walletAddress => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    const tokenAccounts = await handleRpcError(() => connection.getParsedTokenAccountsByOwner(publicKey, {\n      programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')\n    }));\n    return tokenAccounts.value;\n  } catch (error) {\n    console.error('Error fetching token accounts:', error);\n    throw new Error('Failed to fetch token accounts. Please try again later.');\n  }\n};\n\n// Helper function to get 24h volume (mock implementation)\nconst getToken24hVolume = async tokenAddress => {\n  // In a real implementation, you would:\n  // 1. Query DEX APIs (e.g., Raydium, Orca)\n  // 2. Aggregate volume across different DEXes\n  // 3. Return total 24h volume\n  return Math.random() * 1000000; // Mock data\n};\n\n// Helper function to get 24h price change (mock implementation)\nconst getToken24hPriceChange = async tokenAddress => {\n  // In a real implementation, you would:\n  // 1. Get current price\n  // 2. Get price from 24h ago\n  // 3. Calculate percentage change\n  return (Math.random() - 0.5) * 20; // Mock data: -10% to +10%\n};","map":{"version":3,"names":["Connection","PublicKey","SOLANA_RPC_URL","connection","JUPITER_API_URL","delay","ms","Promise","resolve","setTimeout","fetchWithRetry","url","options","retries","i","response","fetch","ok","Error","status","json","error","backoff","Math","min","pow","random","handleRpcError","fn","console","message","includes","fetchTokenData","tokenAddress","_priceData$data$token","tokenPublicKey","tokenSupply","getTokenSupply","priceData","price","data","volume24h","getToken24hVolume","priceChange24h","getToken24hPriceChange","supply","value","uiAmount","getWalletBalance","walletAddress","publicKey","balance","getBalance","getTokenAccounts","tokenAccounts","getParsedTokenAccountsByOwner","programId"],"sources":["/Users/papa/Desktop/trenchboard/trenchboard.io/src/utils/api.js"],"sourcesContent":["import { Connection, PublicKey } from '@solana/web3.js';\n\nconst SOLANA_RPC_URL = 'https://api.mainnet-beta.solana.com';\nconst connection = new Connection(SOLANA_RPC_URL);\n\n// Jupiter API for price data\nconst JUPITER_API_URL = 'https://price.jup.ag/v4/price';\n\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst fetchWithRetry = async (url, options = {}, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      // Exponential backoff with jitter\n      const backoff = Math.min(1000 * Math.pow(2, i) + Math.random() * 1000, 10000);\n      await delay(backoff);\n    }\n  }\n};\n\nconst handleRpcError = async (fn) => {\n  try {\n    return await fn();\n  } catch (error) {\n    console.error('RPC Error:', error);\n    if (error.message.includes('429') || error.message.includes('rate limit')) {\n      throw new Error('Rate limit exceeded. Please try again later.');\n    }\n    throw error;\n  }\n};\n\nexport const fetchTokenData = async (tokenAddress) => {\n  try {\n    const tokenPublicKey = new PublicKey(tokenAddress);\n    \n    // Get token supply with error handling\n    const tokenSupply = await handleRpcError(() => \n      connection.getTokenSupply(tokenPublicKey)\n    );\n    \n    // Get price from Jupiter with retry\n    const priceData = await fetchWithRetry(`${JUPITER_API_URL}?ids=${tokenAddress}`);\n    const price = priceData.data[tokenAddress]?.price || 0;\n\n    // Get mock data for volume and price change\n    const volume24h = await getToken24hVolume(tokenAddress);\n    const priceChange24h = await getToken24hPriceChange(tokenAddress);\n\n    return {\n      price,\n      volume24h,\n      supply: tokenSupply.value.uiAmount,\n      priceChange24h,\n    };\n  } catch (error) {\n    console.error('Error fetching token data:', error);\n    throw new Error('Failed to fetch token data. Please try again later.');\n  }\n};\n\nexport const getWalletBalance = async (walletAddress) => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    const balance = await handleRpcError(() => \n      connection.getBalance(publicKey)\n    );\n    return balance / 1e9; // Convert lamports to SOL\n  } catch (error) {\n    console.error('Error fetching wallet balance:', error);\n    throw new Error('Failed to fetch wallet balance. Please try again later.');\n  }\n};\n\nexport const getTokenAccounts = async (walletAddress) => {\n  try {\n    const publicKey = new PublicKey(walletAddress);\n    const tokenAccounts = await handleRpcError(() => \n      connection.getParsedTokenAccountsByOwner(\n        publicKey,\n        {\n          programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),\n        }\n      )\n    );\n    return tokenAccounts.value;\n  } catch (error) {\n    console.error('Error fetching token accounts:', error);\n    throw new Error('Failed to fetch token accounts. Please try again later.');\n  }\n};\n\n// Helper function to get 24h volume (mock implementation)\nconst getToken24hVolume = async (tokenAddress) => {\n  // In a real implementation, you would:\n  // 1. Query DEX APIs (e.g., Raydium, Orca)\n  // 2. Aggregate volume across different DEXes\n  // 3. Return total 24h volume\n  return Math.random() * 1000000; // Mock data\n};\n\n// Helper function to get 24h price change (mock implementation)\nconst getToken24hPriceChange = async (tokenAddress) => {\n  // In a real implementation, you would:\n  // 1. Get current price\n  // 2. Get price from 24h ago\n  // 3. Calculate percentage change\n  return (Math.random() - 0.5) * 20; // Mock data: -10% to +10%\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}